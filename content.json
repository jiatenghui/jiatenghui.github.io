{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-01-08T07:13:06.000Z","updated":"2018-01-14T04:14:40.171Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"崔佳欢 擅长尬聊，沉迷番剧，支持国足！！！ 番推荐： 123456789《路人女主的养成方法》《埃罗芒阿老师》《某科学的超电磁炮》《迷茫管家与懦弱的我》《这个美术社大有问题》《约会大作战》《伪恋》等等等... 欢迎入坑！！！"}],"posts":[{"title":"es6部分","slug":"es6部分","date":"2018-01-22T12:08:20.000Z","updated":"2018-01-22T12:08:36.501Z","comments":true,"path":"2018/01/22/es6部分/","link":"","permalink":"http://yoursite.com/2018/01/22/es6部分/","excerpt":"","text":"es6学习1.let命令1、let命令用来声明变量，用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效 123456&#123; let a=10; var b=1;&#125;a // referenceError:a is not definedb // 1 这表明，let声明的变量只在它所在的代码块有效 2、for循环的计数器，就很合适使用let命令 1234for (let i = 0; i &lt; 10; i++) &#123; //...&#125;console.log(i); //referenceError:i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错 3、let不允许在相同作用域内重复声明同一个变量 123456789function func() &#123; let a = 10; var a = 1;&#125;function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数 2.const命令1、const声明一个只读的常量。一旦声明，常量的值就不能改变 1234const PI = 3.1215;PI //3.1415PI = 3; // TypeError:Assignment to constant variable 上面代码表示改变常量的值会报错 2、const声明的变量不得改变值，这说明const一旦声明变量，就必须初始化，不得留到以后赋值 12const foo;// SyntaxError:Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错 3、const的作用域与let命令相同，只在声明所在的块级作用域内有效。 1234if(true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError:Max is not defined 4、const声明的常量，也与let一样不可重复声明 12345var message = &quot;Hello!&quot;;let age = 25;//以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; let与const的区别：let是变量，const是常量，只要定义的不会改变就用const 3.变量的解构赋值1、数组的解构赋值 ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 ES6允许写成下面这样： 1let [a,b,c] = [1,2,3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值，这种写法属于“模式匹配”：只要等号两边的模式相同，左边的变量就会被赋予对应的值。 如果解构不成功，变量的值就等于underfined 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，这种情况下，解构依然可以成功 12345678let [x,y] = [1,2,3];x // 1y // 2let [a,[b],d] = [1,[2,3],4];a // 1b // 2d // 4 如果等号的右边不是数组，那么将会报错 1234//报错let [foo] = 1;let [foo] = false;let [foo] = &#123;&#125;; 2、对象的解构赋值 解构还可以应用于对象 123let &#123; foo, bar &#125; = &#123;foo: &quot;aaa&quot;, bar: &quot;bbb&quot;&#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 数组的的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序变量必须与属性同名，才能取到正确的值。 对象的解构赋值可以是下面形式的简写： 1let &#123; foo: foo, bar: bar&#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot;&#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量，真正被赋值的是后者，而不是前者 3、字符串的解构赋值 字符串解构赋值时，被转换成了一个类似数组的对象 123456const [a,b,c,d,e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值 12let &#123;length : len&#125; = &apos;hello&apos;;len // 5 4、数值和布尔值的解构赋值 12 5、函数参数的解构赋值 12 6、圆括号问题 12 7、解构赋值的用途 12 4.字符串的扩展1、字符的 Unicode 表示法 Javascript 允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点 12&quot;\\u0061&quot;// &quot;a&quot; 仅限于码点在\\u0000~\\uFFFF之间的字符，超出这个范围的字符，必须用两个双字节的形式表示。 12345&quot;\\uD842\\uDFB7&quot;// &quot;吉&quot;&quot;\\u20BB7&quot;// &quot; 7&quot; 上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值，Javascript会理解成\\u20BB+7，由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7 ES6对这一点进行了改进，只需将码点放入大括号，就可以正确解读 12345678&quot;\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;&quot;// &quot;ABC&quot;let hello = 123;hell\\u&#123;6F&#125; // 123&apos;\\u&#123;1F680&#125;&apos; === &apos;\\uD83D\\uDE80&apos;// true","categories":[],"tags":[]},{"title":"前端任务","slug":"前端任务","date":"2018-01-22T12:06:34.000Z","updated":"2018-01-22T12:08:00.366Z","comments":true,"path":"2018/01/22/前端任务/","link":"","permalink":"http://yoursite.com/2018/01/22/前端任务/","excerpt":"","text":"元月一号至元月三十一号==1==.块级元素的特点： 独占一行 支持所有样式 不设置宽度时宽度为父元素宽度 换行符不解析 可以容纳内联元素和其他块元素 内联元素的特点： 可以在一行显示 不支持宽高，上下margin和padding等样式会有问题 宽度由内容撑开 换行符会被解析成空格 内联块元素的特点： 内联块元素同时具备块级元素和内联元素的特点 常见的元素的特点属性： href：用于a标签里的链接方式或链接css文件 src：用于链接js文件或图片 alt：用来指定替换文字，只能用在img、area和input元素中，用于网页中图片无法正常显示时给用户提供文字说明使其了解 图像信息 alt是替代图像作用而不是提供额外说明文字 title：作为属性时用来为元素提供额外的说明信息；作为标签时里面写入网页标题 ==2==.html语义化： what：根据内容的结构化，选择合适的语义化标签，便于开发者阅读和代码美观 why： 为了在没有css的情况下，页面也可以很好的体现内容结构代码结构 有利于用户体验 有利于SEO 便于团队开发和维护，语义化更具有可读性 SEO的原理： SEO一共包括三个过程：网页搜索、预处理信息、建立索引。细化分为：爬行—抓取—处理抓取信息—建立索引—呈现排名 一、爬行 爬行的目的：建立待抓取列表 爬虫：谷歌爬虫（ddos）百度爬虫（spider） 1.发现： 对于一个网站来说，分为被动等待和主动引爬虫 被动等待：设置好Robots.txt文件，放在服务器等待爬虫自己过来爬取 主动引爬虫：写带有链接的软文花钱放在高质量高权重的网站中、利用权重高的博客、在质量高的论坛里发外链 2.内容： 争取权重高的位置放 Banner不如幻灯片，幻灯片不如文字，文字优先，图片写alt属性 二、抓取 网页本身需要符合W3C标准，编码建议使用“utf-8”，“title”尽量靠前，我们想让爬虫进入到某个页面就看到我们的主旨内容，内容尽量原创 正文：关键词出现的次数要合适，位置要靠前 “h1标签”：唯一性，整个页面最重要，含关键字，尽量靠前 “h2标签”：可以添加其他属性 “alt属性”：只能用于“img”，意在告诉蜘蛛图片的解释 “title属性”：为链接添加描述性文字，可为用户提供更清楚表达的意思 “锚文本”：锚文本得有相关的关键词，且面面相关 三、处理抓取结果 爬虫抓取后压缩成数据包返回数据库 相关性：因为百度算法语境分析+语义分析的原因，所以网站不要出现不相关的内容出现，否则搜索引擎也会撇掉你的网站权威性（网络拼比，信任度等） 注：不权威造成的影响：同一篇文章，由于信任度高低，有可能自己被转载发布的文章自己的反倒在别人网站后面 去重：一个链接不能有多个页面、同一个关键词不能指向不同链接、同一页面下不要出现不同链接相同的关键词 四、建立索引 搜索引擎的索引是反向建立的（一个关键词对应许多文件[网站/网页]） 什么是爬虫？ 爬虫一般指网络爬虫，是一种按照一定的规则，自动的抓取万维网信息的程序或脚本 如何去写一个爬虫？ ==3==：!Doctype的作用： Doctype是document type的简写，声明叫做文件类型定义（DTD），声明的作用是为了告诉浏览器该文件的类型，让浏览器解析器知道用哪个规范来解析文档，!Doctype必须放在HTML文档的第一行，它不是一个HTML标签 严格模式和混杂模式的区别以及如何触发两种模式 严格模式：又称为标准模式，是指浏览器按照W3C标准解析代码 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码 区别：浏览器解析时到底使用严格模式还是混杂模式，与网页中的DTD相关 1.如果文档包含严格的DOCTYPE，那么它一般以严格模式呈现。（严格DTD——严格模式） 2.包含过渡DTD和URL的DOCTYPE，也以严格模式呈现，但有过渡DTD而没有URL（统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有URL的过渡DTD——严格模式；没有URL的过渡DTD——混杂模式） 3.DOCTYPE不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式） 4.HTML5没有DTD，因此也就没有严格模式与混杂模式的区别，HTML5有相对宽松得语法，实现时，已经尽可能大的实现了向后兼容。（HTML没有严格与混杂之分） ==4：==.DOM树 什么是DOM? DOM是Document Object Model（文档对象模型）的缩写，是W3C的标准，它定义了访问HTML和XML文档的标准：“W3C文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。” W3C DOM标准被分为3个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对XML文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 什么是HTML DOM？ HTML DOM 是： HTML 的标准对象模型 HTML 的标准编程接口 W3C 标准 HTML DOM定义了所有HTML元素的对象和属性，以及访问它们的方法。 换言之，HTML DOM是关于如何获取、修改、添加或删除HTML元素的标准 如何去优化DOM结构？ 1把DOM和Javascript各自想象成一个岛屿，它们之间用收费桥梁连接 因此要避免去操作DOM，还要减少去访问DOM的次数。 ==5==.标签嵌套规则及HTML转义 1.块级元素 div、h1~h6、address、blockquote、center、dir、dl、dt、dd、fieldset、form、hr、isindex、menu、nooframes、noscript、ol、p、pre、table、ul... 特点：总是在新行上开始，高度、行高以及顶和底边距都可控制，宽度缺省是它的容器的100%，除非设定一个宽度 功能：主要用来搭建网站架构、页面布局、承载内容 2.行内元素 span、a、abbr、acronym、b、bdo、big、br、cite、code、dfn、em、font、i、img、input、kbd、label、q、s、samp、select、small、strike、strong、sub、sup、textarea、tt、u、var ... 特点：和其他元素都在一行上，高、行高及顶和底边距不可改变，宽度就是它的文字或图片的宽度，不可改变 功能：用于加强内容显示,控制细节，例如：加粗、斜体等等 HTML转义","categories":[],"tags":[]},{"title":"swiper入门学习","slug":"swiper入门学习","date":"2018-01-21T16:57:30.000Z","updated":"2018-01-21T17:46:45.000Z","comments":true,"path":"2018/01/22/swiper入门学习/","link":"","permalink":"http://yoursite.com/2018/01/22/swiper入门学习/","excerpt":"","text":"什么是swiper？swiper是一种用于移动端页面的前端特效插件，它是一种纯javascript的框架，主要用来做轮播图之类页面，在使用之前首先我们需要下载swiper 注：下载swiper-4.1.0.min.js和swiper-4.1.0.min.css即可 swiper使用方法1.首先加载插件1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ... &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/swiper.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; ... &lt;script src=&quot;path/to/swiper.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.HTML内容1234567891011121314151617&lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt;&lt;/div&gt;导航等组件可以放在container之外 注：可以自行给swiper定义大小 3.初始化swiper1234567891011121314151617181920212223&lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, &#123; direction: &apos;vertical&apos;, loop: true, // 如果需要分页器 pagination: &#123; el: &apos;.swiper-pagination&apos;, &#125;, // 如果需要前进后退按钮 navigation: &#123; nextEl: &apos;.swiper-button-next&apos;, prevEl: &apos;.swiper-button-prev&apos;, &#125;, // 如果需要滚动条 scrollbar: &#123; el: &apos;.swiper-scrollbar&apos;, &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 4.如何利用swiper实现一个简单的轮播图效果 默认前三项都成功完成 首先先上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;swiper-4.1.0.min.css&quot;&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .swiper-container &#123; width: 600px; height: 300px; &#125; .swiper-slide&#123; font-size: 50px; &#125; .swiper-slide:nth-of-type(1)&#123; background-color: cornflowerblue; &#125; .swiper-slide:nth-of-type(2)&#123; background-color: coral; &#125; .swiper-slide:nth-of-type(3)&#123; background-color: yellowgreen; &#125; .swiper-slide:nth-of-type(4)&#123; background-color: coral; &#125; .swiper-slide:nth-of-type(5)&#123; background-color: cornflowerblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 3&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 4&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;swiper-4.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, &#123;// horizontal 水平 // vertical 垂直 direction: &apos;horizontal&apos;,// 开始显示第几张 initialSlide: 0,// 换页速度 speed: 1500,// 自动切换 autoplay: &#123; delay: 2000, &#125;, &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; initialSlide参数：设定初始化时slide页面的索引，初始时为0，即默认为轮播图第一张图；如果设置为2时，swiper初始化时页面就是轮播图第三张图 direction参数：设置轮播图的滑动方向，水平方向为（horizontal），垂直方向为（vertical），默认为水平方向 speed参数：轮播图的切换速度 autoplay参数：设置为true时自动切换图片，默认为false delay参数：自动切换的时间间隔，详情见上图代码 关于swiper的用法和初始化组件还有许多，具体请查看swiperAPI文档","categories":[],"tags":[]},{"title":"webpack入门学习","slug":"webpack入门学习","date":"2018-01-08T02:14:35.000Z","updated":"2018-01-08T02:26:07.181Z","comments":true,"path":"2018/01/08/webpack入门学习/","link":"","permalink":"http://yoursite.com/2018/01/08/webpack入门学习/","excerpt":"","text":"什么是Webpack?Webpack是一个前端资源加载/打包工具，它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源. 通俗地讲，Webpack可以看作是模块打包机：它做的事情是，分析你的项目结构，找到Javascript模块以及其他的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 Webpack与Gulp区别Webpack与之前学习的gulp相比较而言，两者的流程不大相同，而且Wwbpack的处理速度更快更直接，能打包更多不同类型的文件。 gulp是一种能够优化前端的开发流程的工具，它的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。 Webpack是一种模块化的解决方案，它的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的Javascript文件。 【注:loader用于对模块的源代码进行转换,比如Webpack只能处理js文件，因此对于css文件就需要安装对应loader模块：style-loader和css-loader等】 从图中可以看出，Webpack可以将多种静态资源js,css,less转换成一个静态文件。 使用Webpack安装Webpack在安装之前，需要检查本地环境是否支持node.js 使用npm安装Webpack 1npm install webpack -g 创建一个文件夹在你的电脑随便一个盘里创建一个新的文件夹或者使用命令创建: 1mkdir webpack-test 在文件夹中新建一个run1.js文件，代码如下： 1document.write(&quot;Hello World&quot;); 再添加index.html文件，代码如下： 12345678&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt; &lt;/body&gt;&lt;/html&gt; 接下来使用Webpack命令进行打包： 1webpack run1.js bundle.js 执行以上命令会编译run1.js文件并生成bundle.js文件 在浏览器中打开index.html文件，会看到页面上有“Hello World”。 Loader就像之前说的，如果想要处理除js之外的其他文件，对于css文件，首先需要执行命令来安装css-loader和style-loader 1npm install css-loader style-loader 接下来创建一个style.css文件，代码如下： 123body&#123; background:red;&#125; 修改run1.js文件： 12require(&quot;!style-loader!css-loader!./style.css&quot;);document.write(&quot;Hello World&quot;); 继续使用Webpack命令打包： 1webpack run1.js bundle.js 在浏览器访问index.html会发现背景变成红色。 配置文件可以将一些编译选项放在配置文件中，以便于统一管理。 创建webpack.config.js文件 123456789101112module.exports = &#123; entry: &quot;./run1.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/,loader: &quot;style.loader!css-loader&quot;&#125; ] &#125;&#125;; 接下来只需要执行webpack命令即可生成bundle.js文件 Webpack命令执行后，会默认载入当前目录的webpack.config.js文件。 当你想要查看你添加的loaders模块时。可以在安装webpack之后再生成一个package.json文件,它里面会显示你当前所有的依赖模块，代码如下： 1npm init 默认一直点回车就行 开发环境如果不想每次修改模块之后还要重新编译，那么可以启用监听模式；开启之后，就不需要每次都重新编译，代码如下： 1webpack --watch 当然还有一种方法是启用一个本地服务器，来实现热加载，可以使用webpack-dev-server服务，当然首先需要安装： 1npm install webpack-dev-server -g 运行： 1webpack-dev-server 运行之后一般会通过localhost:8080启用一个express静态资源web服务器，并且会以监听模式自动运行webpack；如果该端口被占用，可以通过“ -port 端口号 ” 来改变服务器端口。 当然webpack还有其他功能，我也还在学习当中。","categories":[],"tags":[]},{"title":"npm学习","slug":"npm学习","date":"2017-12-30T07:18:22.000Z","updated":"2018-01-02T12:25:46.139Z","comments":true,"path":"2017/12/30/npm学习/","link":"","permalink":"http://yoursite.com/2017/12/30/npm学习/","excerpt":"","text":"什么是npm？它有什么作用？ npm是和node.js一起的包管理工具，并且在安装node.js时已经安装好了npm,npm常见的使用场景有以下几个: 1231.允许用户从npm服务器下载别人编写的第三方包到本地使用。2.允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。3.允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。 安装npm npm本地安装的命令为: 1npm install npm 全局安装的命令为: 1npm install npm -g 如果要检查是否安装成功可以输入命令行: 1npm -v 来测试是否安装成功。 使用package.jsonpackage.json位于模块的目录下，用于定义包的属性。 在当前目录下产生package.json文件1npm init 安装当前package,json中定义的模块1npm install 注册与提交注册用户1234npm adduserUsername:输入用户名Password:输入密码Email:输入邮箱 编写完模块后输入命令行:1npm publish #发表模块 更新模块 尽管node.js自带pm，但是如果想要更新npm的话。可以输入命令: 1npm update npm -g 搜索模块1npm search &quot;Module Name&quot;","categories":[],"tags":[]},{"title":"gulp学习","slug":"gulp学习","date":"2017-12-28T11:05:28.000Z","updated":"2018-01-02T12:25:49.889Z","comments":true,"path":"2017/12/28/gulp学习/","link":"","permalink":"http://yoursite.com/2017/12/28/gulp学习/","excerpt":"","text":"gulp作为前端开发过程中对代码进行构建的工具，对它进行了解学习是必要的，它可以提高我们的学习和工作效率 要使用gulp，首先要明白它是基于node.js下运行的，所以我们需要先安装node.js，安装完成后再安装gulp，这里分为全局安装gulp与本地安装gulp：对于全局安装，它的目的是为了通过它执行gulp任务;安装的命令提示符是： 1npm install gulp -g 安装好之后，可以使用 1gulp -v 来进行验证，如果出现版本号即为正确安装 而本地安装只需要将”-g”去掉 1npm install gulp 安装完成之后我们需要新建一个package,json文件 说明：package.json是基于node.js项目必不可少的配置文件，它是存放在项目根目录的json文件(在之后的gulpfile.js编写中也可以当做检查gulp插件是否调入的判断)安装的命令提示符 1npm init 这里需要说明一下package.json文件里的内容 123456789101.name:项目名称2.version:版本号3.description:项目描述4.homepage:项目网站5.author:作者姓名6.contributors:其他相关人姓名7.dependencies:包(插件)列表，默认在node_modules目录下8.repository:包(插件)存放地方的类型，可以是git或svn,git可在GitHub上9.main:main字段指定了程序的主入口文件，require(&apos;moduleName&apos;)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js10.keywords:关键字 在gulp里面的主要知识点我个人认为是在于写gulpfile.js文件举例说明 123456var sass = require(&apos;gulp-sass&apos;); //将插件导入文件中并命名gulp.task(&apos;sass&apos;,function()&#123; //定义一个匿名函数return gulp.src(&apos;stylesheets/**/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); gulp.src() –找出需要处理的文件 .pipe() –指定需要执行的功能 gulp.desk() –将处理好的文件放到指定的位置 像例子中的sass就是一个插件，它的功能是将文件变为.css格式的文件,安装方式是 1npm install gulp-sass --save-dev 其他插件的安装方式与用法基本类似,不多描述 下面是我对gulp中的几个API的理解1.gulp.src()利用这个方法可以读取你需要的文件，语法为:1gulp.src(globs[,optios]) globs参数是文件匹配模式，用来匹配文件路径；当有多个模式时，该参数为一个数组；options为可选参数，通常用不到 2.gulp.dest()用来写文件，其语法为:1gulp.dest(path[,optios]) path为写入文件的路径；options为可选参数，通常用不到 3.gulp.task()用来定义任务，语法为:1gulp.task(name[,deps],fn) name为任务名；deps是当前定义的任务需要依赖其他任务；fn为任务函数，任务要执行的代码写在里面 4.gulp.watch()用来监视文件的变化，当文件发生变化后，可以利用它来执行相应的任务,语法为:1gulp.watch(glob[,opta],tasks) glob为要监视的文件匹配模式；opts为一个可选的配置对象，通常不用；tasks为文件变化后要执行的任务，为一个数组","categories":[],"tags":[]},{"title":"Git学习","slug":"git学习","date":"2017-12-26T06:42:13.000Z","updated":"2018-01-02T12:25:52.179Z","comments":true,"path":"2017/12/26/git学习/","link":"","permalink":"http://yoursite.com/2017/12/26/git学习/","excerpt":"","text":"什么是Git？Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理，而对于大家熟知的Github来说，它是一个用Git做版本控制的项目托管平台如图： 在这里我把我学习Git过程中的知识总结出来，供大家参考 要想使用Git，首先我们需要来安装Git，这里我把链接放在这，有兴趣的兄dei可以来下载安装链接 密码：ue9y 下载好之后，我们就开始正式了解Git 因为在建博客时也用到了Git，因此我主要说明一下Git如何进行远程连接和下载提交工程要使用Git，我们首先要告诉Git我们是谁一般填写的都是Github的用户名和注册邮箱 1git config --global user.name &apos;你的名称&apos; 1git config --global user.email &apos;你的邮箱&apos; 初始化在任意一个地方新建一个文件，然后在文件中打开git，输入初始化命令 1git init 即初始化完成 提交过程首先我们需要先查看当前文件的状态 1git status 它会显示出当前我们所在的分支，比如“on branch master”表示我们现在处在master这个分支上，即主分支 当我们在文件中新建文件之后，再次运行“git status”时，结果会以红色字体出现新建文件名，即git未跟踪文件，现在我们需要将未跟踪文件添加进来，输入 1git add . #表示添加所有修改文件 或1git add 文件名 #表示添加某一文件 再次运行“git status”，会显示绿色字体，表示该文件将要被提交，这时需要确认提交 1git commit -m &apos;提交信息&apos; #提交信息主要写你提交了什么文件 提交完成 注：一旦修改了跟踪文件的内容，就要重新进行提交 创建分支先查看所有分支 1git branch 分支名称左边有“*”的默认为当前分支 创建分支 1git branch 分支名 既然分支创建好了，如何切换分支呢？我们需要输入命令 1git checkout 分支名 下载版本库1git clone 远程版本库地址 #默认名称为版本库名称，可以在后面加上自定义的名称 下载完成后，就可以在本地对版本库进行修改 提交版本库当修改完成之后，在git里面输入1git push origin master 完成提交 但是远程版本库并不知道你已经更新了状态，这个时候我们需要输入 1git fetch 提示已经提取到更新，然后查看状态 1git status 查看显示远程上已经有了更新，然后我们需要进行 1git merge origin/master 这个时候当前分支就与“master”分支保持一致了","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2017-12-25T14:13:47.000Z","updated":"2017-12-25T15:03:55.311Z","comments":true,"path":"2017/12/25/第一篇博客/","link":"","permalink":"http://yoursite.com/2017/12/25/第一篇博客/","excerpt":"","text":"经历千辛万苦，我终于建好了我的个人博客，期间在网上翻看了不少前辈的教程和方法，也选择了各种建造博客的工具，最后还是使用最顺手的一个来用了，我的博客主要是分享学习新知识的总结和理解，以及生活中的一些有趣的故事，说来惭愧，小白我虽然学习的是前端，但也有那么一丢丢文学细胞，也想通过自己写的文章来让别人感受到不同的自己，今后会不定时更新的哦","categories":[],"tags":[]}]}