{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-01-08T07:13:06.000Z","updated":"2018-01-23T18:27:38.414Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"崔佳欢"}],"posts":[{"title":"思考跨域问题","slug":"思考跨域问题","date":"2018-01-27T11:31:21.000Z","updated":"2018-01-29T16:45:06.685Z","comments":true,"path":"2018/01/27/思考跨域问题/","link":"","permalink":"http://yoursite.com/2018/01/27/思考跨域问题/","excerpt":"","text":"ajax跨域问题 什么是跨域问题？跨域就是指浏览器不能执行其他网站的脚本，这是由浏览器的同源策略造成的，是javascript的安全限制 一个域名地址是由： http://(请求头) www(子域名) . cuijahuan(主域名) : 8080(端口号) / script/jquery.js(请求资源地址) 组成的 而同源，就是指域名，协议，端口均相同 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域 而不同域之间的相互请求资源，就是跨域比如http://cuijiahuan.xyz 请求 http://jiahuan.xyz 解决方法1、使用ajax的JSONP 首先要了解JSONP只支持GET请求，不支持POST请求 ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性可以访问跨域的js脚本，因此，服务器不再返回JSON格式的数据，而是返回一段调用某个函数的JS代码，在src中进行了调用，实现了跨域。 还没有看jsonp，目前我只知道要在ajax里面引入 type:&quot;get&quot;, // 接收服务器数据的类型 dataType:&quot;jsonp&quot;, // 用于服务器端的获取函数的参数 jsonp:&quot;callback&quot;, // 函数名称 2、使用jquery的jsonp插件 首先我们要引入相关的js文件，相关下载可参考该地址 在我们前端代码中需要在ajax里的url下加入 callbackParameter:&quot;callback&quot; callback:&quot;callback_success&quot; 使用该方法不局限于get请求，还可以是post请求，但从服务器获取到的依然是jsonp格式 第三种方法是使用cors方法，具体可以参考网上其他博客","categories":[],"tags":[]},{"title":"es6学习第二篇","slug":"es6学习第二篇","date":"2018-01-26T14:34:26.000Z","updated":"2018-01-26T16:18:56.489Z","comments":true,"path":"2018/01/26/es6学习第二篇/","link":"","permalink":"http://yoursite.com/2018/01/26/es6学习第二篇/","excerpt":"","text":"es6学习第二篇 后续会持续更新 一、模板字符串1、基本的字符串格式化，将表达式嵌入字符串中进行拼接。用${}来界定。 12const name = &apos;laowang&apos;console.log`(hello $(name)`) // hello laowang 2、通过反引号(``)来对多行字符串或者字符串一行行拼接 123const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;` 3、其他常用的es6方法 123456789// 1. includes:判断是否包含然后直接返回布尔值let str = &apos;hahay&apos;console.log(str.includes(&apos;y&apos;)) // true// 2. repeat:获取字符串重复n次let s = &apos;he&apos;console.log(s.repeat(3)) // &apos;hehehe&apos;//如果你带入小数，Math.floor(num)来处理 二、函数1、函数默认参数 es6为参数提供了默认值。在定义函数时编初始化了这个参数，以便在参数没有被传递进去时使用 12345function action(num = 200)&#123; console.log(num)&#125;action() //200action(300) //300 2、箭头函数 箭头函数最直观的三个特点。 不需要function关键字来创建函数 省略return关键字 继承当前上下文的this关键字 1234567//例：[1,2,3].map( x=&gt; x + 1 )//等同于：[1,2,3].map((function(x)&#123; return x + 1&#125;).bind(this)) 三、扩展的对象功能es6对于对象都是以键值对的形式书写。很有可能出现键值对重名。如： 123456function people(name, age) &#123; return &#123; name, age &#125;;&#125; es6同样改进了为对象字面量方法赋值的语法，通过省略冒号与function关键字，将这个语法变得更简洁 123456const people = &#123; name: &apos;laowang&apos;, getName () &#123; console.log(this.name) &#125;&#125; es6对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际中，为了不改变源对象。一般会把目标对象传位{} 1const obj = Object.assign(&#123;&#125;,objA,objB)","categories":[],"tags":[]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2018-01-25T16:17:48.000Z","updated":"2018-01-25T17:27:32.218Z","comments":true,"path":"2018/01/26/HTTP状态码/","link":"","permalink":"http://yoursite.com/2018/01/26/HTTP状态码/","excerpt":"","text":"什么是HTTP状态码？ 当浏览器访问一个网页时所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server ）用以响应浏览器的请求。 常见的HTTP状态码 200 — 请求成功 301 — 资源（网页等）被永久转移到其他URL 404 — 请求的资源（网页等）不存在 500 — 内部服务器错误 HTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： HTTP状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表 状态码 状态码英文名称 中文描述 100 continue 继续，客户端应继续其请求 101 switching protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 created 已创建。成功请求并创建了新的资源 202 accepted 已接受。已经接受请求，但未处理完成 203 non-authoritative information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 no content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 reset content 重置内容。服务器成功处理，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 partial content 部分内容。服务器成功处理了部分GET请求 300 multiple choices 多种选择。请求的资源可包括多个位置相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 moved permanently 永久移动。请求的资源已被永久的移动到新URL，返回信息会包括新的URL，浏览器会自动的定向到新URL。今后任何新的请求都应使用新的URL代替 302 found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URL 303 see other 查看其它地址。与301类似。使用GET和POST请求查看 304 not modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在制定日期之后修改的资源 305 use proxy 使用代理。所请求的资源必须通过代理访问 306 unused 已经被废弃的HTTP状态码 307 tomporary redirect 临时重定向。与302类似。使用GET请求重定向 400 bad request 客户端请求的语法错误，服务器无法理解 401 unauthorized 请求要求用户的身份认证 402 payment required 保留，将来使用 403 forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 not found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置“您所请求的资源无法找到”的个性页面 405 method not allowed 客户端请求中的方法被禁止 406 not acceptable 服务器无法根据客户端请求的内容特性完成请求 407 proxy authentication required 请求要求代理的身份认证，与类似，但请求者应当使用代理进行授权 408 request time-out 服务器等待客户端发送的请求时间过长，超时 409 conflict 服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发生了冲突 410 gone 客户端请求的资源已经不存在，410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 length 服务器无法处理客户端发送的不带Content-Length的请求信息 412 precondition failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理","categories":[],"tags":[]},{"title":"HTML5新特性","slug":"HTML5新特性","date":"2018-01-23T18:17:20.000Z","updated":"2018-01-23T18:17:37.532Z","comments":true,"path":"2018/01/24/HTML5新特性/","link":"","permalink":"http://yoursite.com/2018/01/24/HTML5新特性/","excerpt":"","text":"HTML5新特性一、新的语义化标签1. &lt;section&gt;&lt;/section&gt; 定义文档中的主体部分的节、段。 2. &lt;article&gt;&lt;/article&gt; 一个特殊的section标签，比section有更明确的语义。定义来自外部的一个独立的、完整的内容块，例如某个论坛的文章、博客的文本等 3. &lt;aside&gt;&lt;/aside&gt; 用来装载页面中非正文的内容，独立于其他模块，例如广告、成组的链接、侧边栏等 4. &lt;header&gt;&lt;/header&gt; 定义文档、页面的页眉。通常是一些引导和导航信息，不局限于整个页面头部，也可以用在内容里。 5. &lt;footer&gt;&lt;/footer&gt; 定义了文档、页面的页脚，和header类似。 6. &lt;nav&gt;&lt;/nav&gt; 定义了一个链接组组成的导航部分，其中的链接可以链接到其他网页或者当前页面的其他部分。 7. &lt;hgroup&gt;&lt;/hgroup&gt; 用于对网页或区段的标题元素进行组合。 8. &lt;figure&gt;&lt;/figure&gt; 用于对元素进行组合。 9. &lt;figcaption&gt;&lt;/figcaption&gt; 为figure元素加标题。一般放在figure第一个子元素或者最后一个。 10. &lt;details&gt;&lt;/details&gt; 定义元素的细节，用户可以点击查看或者隐藏。 11. &lt;summary&gt;&lt;/summary&gt; 和details连用，用来包含details的标题。 12. &lt;canvas&gt;&lt;/canvas&gt; 用来进行canvas绘图。 13. &lt;video&gt;&lt;/video&gt; 定义视频。 14. &lt;audio&gt;&lt;/audio&gt; 定义音频 15. &lt;embed&gt;&lt;/embed&gt; 定义嵌入网页的内容。比如插件。 16. &lt;source&gt;&lt;/source&gt; 该标签为媒介元素（比如video、audio）定义媒介元素。 17. &lt;detailst id=’dl’&gt;&lt;/detailst&gt; 定义可选数据的列表，与input配合使用（&lt;input list=’dl’&gt;）可制作输入值的下拉列表。 18. &lt;mark&gt;&lt;/mark&gt; 在视觉上向用户展现出那些想要突出的文字。比如搜索结果中向用户高亮显示搜索关键词。 19. &lt;meter [min/max/low/high/optimum/value]&gt;&lt;/meter&gt; 度量衡，用红黄绿表示出一个数值所在范围。 20 &lt;output&gt;&lt;/output&gt; 定义不同类型的输出，样式与span无异。 21. &lt;progress&gt;&lt;/progress&gt; 进度条，运行中的速度。 22. &lt;time&gt;&lt;time&gt; 定义日期或者时间。 23. &lt;keygen&gt;&lt;/keygen&gt; 定义加密内容。 24. &lt;command&gt;&lt;/command&gt; 定义命令行为。 二、新的Javascript的API2D绘图我们学过的canvas和svg动画都属于javascript的API， canvas： canvas通过javascript来绘制2D图形 canvas是逐像素进行渲染的 在canvas中，一旦图形被绘制完成，它就不会继续得到浏览器的关注，如果位置发生变化，那么整个场景也需要重新绘制，包括任何已经被图形覆盖的对象。 SVG： SVG是一种使用XML描述2D图形的语言 SVG基于XML，这意味着SVG DOM中的每个元素都是可用的，你可以为某个元素附加javascript事件处理器 在SVG中，每个被绘制的图形均被视为对象。如果SVG对象的属性发生变化，那么浏览器能够自动重现图形 两者区别 canvas与SVG的比较 canvas: 1、canvas依赖分辨率 2、不支持事件处理器 3、弱的文本渲染能力 4、能够以 .png 或 .jpg格式保存结果图像 SVG: 1、不依赖分辨率 2、支持事件处理器 3、最适合带有大型渲染区域的应用程序（如：google map） 4、复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） history对象history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前，这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值，负数表示向后跳转【类似浏览器的“后退”按钮】，正数表示向前跳转【类似浏览器的“前进”按钮】 123history.go(-1); // 后退一页history.go(1)； // 前进一页history.go(2); //前进两页 也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置：可能后退，也可能前进，具体由位置近的决定。如果历史记录中不包含该字符串，那么这个方法什么也不做 1history.go(&apos;worx.com&apos;); 跳到最近的wrox.com页面 还可以使用两个简写方法back()和forward()来代替go() 12history.back(); // 后退一页history.forward(); // 前进一页 除此之外，history对象还有一个length属性，保存着历史记录的数量，这个数量包括所有的历史记录，即所有向后和向前的记录。 HTML5 Web 存储如何在客户端存储数据？ HTML5提供了两种在客户端存储数据的新方法： localStorage — 没有时间限制的数据存储 sessionSSStorage — 针对一个session的存储数据 之前我们学习的cookie缓存并不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得cookie速度很慢而且效率也不高 在HTML5中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据，它使在不影响网站性能的情况下存储大量数据成为可能 对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据 HTML5通过javascript来存储和访问数据 localStorage方法localStorage方法存储的数据没有时间限制，长时间之后数据依然可用， 创建和访问localStorage 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt;// Check browser supportif (typeof(Storage) !== &quot;undefined&quot;) &#123; // Store localStorage.setItem(&quot;lastname&quot;, &quot;Gates&quot;); // Retrieve document.getElementById(&quot;result&quot;).innerHTML = localStorage.getItem(&quot;lastname&quot;);&#125; else &#123; document.getElementById(&quot;result&quot;).innerHTML = &quot;抱歉！您的浏览器不支持 Web Storage ...&quot;;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面是对用户访问页面次数进行计数 123456789101112131415161718192021222324&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;if (localStorage.pagecount) &#123; localStorage.pagecount=Number(localStorage.pagecount) +1; &#125;else &#123; localStorage.pagecount=1; &#125;document.write(&quot;Visits: &quot; + localStorage.pagecount + &quot; time(s).&quot;);&lt;/script&gt; &lt;p&gt;刷新页面会看到计数器在增长。&lt;/p&gt;&lt;p&gt;请关闭浏览器窗口，然后再试一次，计数器会继续计数。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; sessionStorage方法sessionStorage方法针对一个session进行数据存储，当用户关闭浏览器窗口之后，数据会被删除 创建并访问一个sessionStorage： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function clickCounter() &#123; if(typeof(Storage) !== &quot;undefined&quot;) &#123; if (sessionStorage.clickcount) &#123; sessionStorage.clickcount = Number(sessionStorage.clickcount)+1; &#125; else &#123; sessionStorage.clickcount = 1; &#125; document.getElementById(&quot;result&quot;).innerHTML = &quot;在本 session 中，您已经点击这个按钮 &quot; + sessionStorage.clickcount + &quot; 次。&quot;; &#125; else &#123; document.getElementById(&quot;result&quot;).innerHTML = &quot;抱歉！您的浏览器不支持 Web Storage ...&quot;; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;button onclick=&quot;clickCounter()&quot; type=&quot;button&quot;&gt;请点击这里&lt;/button&gt;&lt;/p&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;p&gt;请点击按钮使计数器递增。&lt;/p&gt;&lt;p&gt;请关闭浏览器或标签页，然后再试一次，计数器会重置。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 下面对当前session中访问页面的次数进行计数： 123456789101112131415161718192021222324&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;if (sessionStorage.pagecount) &#123; sessionStorage.pagecount=Number(sessionStorage.pagecount) +1; &#125;else &#123; sessionStorage.pagecount=1; &#125;document.write(&quot;Visits &quot; + sessionStorage.pagecount + &quot; time(s) this session.&quot;);&lt;/script&gt; &lt;p&gt;刷新页面会看到计数器在增长。&lt;/p&gt;&lt;p&gt;请关闭浏览器窗口，然后再试一次，计数器已经重置了。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;video&gt;和&lt;audio&gt;用法1&lt;video src=&quot;./video/mv.mp4&quot;&gt;&lt;/video&gt; 注意audio和video元素必须同时包含开始和结束标签，不能使用&lt;audio/&gt;这样的空元素语法形式。 HTML属性controls:ontrol如果出现该属性，则向用户显示控件，如播放按钮，每个浏览器播放控件不一样，但是用途一致，都可以控制开始和结束，跳到新位置和调节音量。 autoplay:autoplay如果出现该属性，则视频在就绪后马上播放，如果不设置autoplay属性，必须是用户单机播放按钮才会播放。 loop:loop循环播放 preload:auto、mete、none:告诉浏览器如何下载音频 auto:让浏览器下载整个文件，以便用户单机播放按钮就能播放 meta:告诉浏览器先获取音频文件开头的数据块，从而足以确定一些基本信息（比如音频的总时长） none:告诉浏览器不必预先下载，合理利用这些值 常用API属性duration:返回当前音频、视频的长度（单位：S） paused:设置或返回音频、视频是否暂停 currentTime:设置或返回音频/视频中的当前播放位置（单位：S） ended:返回音频、视频的播放是否已结束 如需具体了解请参考W3school书册 如果还想了解更多的API，请点击访问查看更多javascript的API 三、H5头部声明H5将DOCTYPE的声明简化，只需要&lt;!DOCTYPE&gt; 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; doctype是document type（文档类型）的简写，在页面中，用来指定页面所使用的xhtml（或者html）的版本。要想制作符合标准的页面，一个必不可少的关键组成部分就 是doctype声明。只有确定了一个正确的doctype，xhtml里的标识和css才能正常生效。 html 告诉浏览器这个文件是html格式网页文件 两个合起来就是 html5标准网页声明,原先的是一串很长的字符串,现在是这个简洁形式,支持html5标准的主流浏览器都认识这个声明。","categories":[],"tags":[]},{"title":"es6学习第一篇","slug":"es6学习第一篇","date":"2018-01-23T12:08:20.000Z","updated":"2018-01-26T16:20:26.256Z","comments":true,"path":"2018/01/23/es6学习第一篇/","link":"","permalink":"http://yoursite.com/2018/01/23/es6学习第一篇/","excerpt":"","text":"es6学习第一篇 后续会持续更新 一、let命令1、let命令用来声明变量，用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效（我的理解感觉有点像js中的局部变量） 123456&#123; let a=10; var b=1;&#125;a // a is not definedb // 1 2、let在循环中可以正常使用，但是只在循环内部有效，在外边引用会出错 1234for (let i = 0; i &lt; 10; i++) &#123; //...&#125;alert(i); // i is not defined 3、let不允许在同一个域内重复声明一个变量 123456789function func() &#123; let a = 10; var a = 1;&#125;function func() &#123; let a = 10; let a = 1;&#125; 二、const命令1、const声明一个只读的常量。一旦声明，常量的值就不能改变 1234const PI = 3.1215;PI //3.1415PI = 3; // TypeError:Assignment to constant variable 2、const一旦声明变量，就必须初始化，不能在后面赋值，另外对const来说，只声明不赋值会出错。 12const foo;// SyntaxError:Missing initializer in const declaration 3、const只在声明所在的块级作用域内有效。 1234if(true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError:Max is not defined 4、const声明的常量，也与let一样不可重复声明 12345var message = &quot;Hello!&quot;;let age = 25;//以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; let与const的区别：let是变量，const是常量，只需要定义的不用改变的值就用const 三、数组的解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 ES6允许写成下面这样： 1let [a,b,c] = [1,2,3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值，这种写法属于“模式匹配”：只要等号两边的模式相同，左边的变量就会被赋予对应的值。 如果解构不成功，变量的值就等于underfined 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，这种情况下，解构依然可以成功 12345678let [x,y] = [1,2,3];x // 1y // 2let [a,[b],d] = [1,[2,3],4];a // 1b // 2d // 4 如果等号的右边不是数组，那么将会报错 1234//报错let [foo] = 1;let [foo] = false;let [foo] = &#123;&#125;;","categories":[],"tags":[]},{"title":"前端任务","slug":"前端任务","date":"2018-01-22T12:06:34.000Z","updated":"2018-01-22T12:15:58.047Z","comments":true,"path":"2018/01/22/前端任务/","link":"","permalink":"http://yoursite.com/2018/01/22/前端任务/","excerpt":"","text":"元月一号至元月三十一号==1==.块级元素的特点： 独占一行 支持所有样式 不设置宽度时宽度为父元素宽度 换行符不解析 可以容纳内联元素和其他块元素 内联元素的特点： 可以在一行显示 不支持宽高，上下margin和padding等样式会有问题 宽度由内容撑开 换行符会被解析成空格 内联块元素的特点： 内联块元素同时具备块级元素和内联元素的特点 常见的元素的特点属性： href：用于a标签里的链接方式或链接css文件 src：用于链接js文件或图片 alt：用来指定替换文字，只能用在img、area和input元素中，用于网页中图片无法正常显示时给用户提供文字说明使其了解 图像信息 alt是替代图像作用而不是提供额外说明文字 title：作为属性时用来为元素提供额外的说明信息；作为标签时里面写入网页标题 ==2==.html语义化： what：根据内容的结构化，选择合适的语义化标签，便于开发者阅读和代码美观 why： 为了在没有css的情况下，页面也可以很好的体现内容结构代码结构 有利于用户体验 有利于SEO 便于团队开发和维护，语义化更具有可读性 SEO的原理： SEO一共包括三个过程：网页搜索、预处理信息、建立索引。细化分为：爬行—抓取—处理抓取信息—建立索引—呈现排名 一、爬行 爬行的目的：建立待抓取列表 爬虫：谷歌爬虫（ddos）百度爬虫（spider） 1.发现： 对于一个网站来说，分为被动等待和主动引爬虫 被动等待：设置好Robots.txt文件，放在服务器等待爬虫自己过来爬取 主动引爬虫：写带有链接的软文花钱放在高质量高权重的网站中、利用权重高的博客、在质量高的论坛里发外链 2.内容： 争取权重高的位置放 Banner不如幻灯片，幻灯片不如文字，文字优先，图片写alt属性 二、抓取 网页本身需要符合W3C标准，编码建议使用“utf-8”，“title”尽量靠前，我们想让爬虫进入到某个页面就看到我们的主旨内容，内容尽量原创 正文：关键词出现的次数要合适，位置要靠前 “h1标签”：唯一性，整个页面最重要，含关键字，尽量靠前 “h2标签”：可以添加其他属性 “alt属性”：只能用于“img”，意在告诉蜘蛛图片的解释 “title属性”：为链接添加描述性文字，可为用户提供更清楚表达的意思 “锚文本”：锚文本得有相关的关键词，且面面相关 三、处理抓取结果 爬虫抓取后压缩成数据包返回数据库 相关性：因为百度算法语境分析+语义分析的原因，所以网站不要出现不相关的内容出现，否则搜索引擎也会撇掉你的网站权威性（网络拼比，信任度等） 注：不权威造成的影响：同一篇文章，由于信任度高低，有可能自己被转载发布的文章自己的反倒在别人网站后面 去重：一个链接不能有多个页面、同一个关键词不能指向不同链接、同一页面下不要出现不同链接相同的关键词 四、建立索引 搜索引擎的索引是反向建立的（一个关键词对应许多文件[网站/网页]） 什么是爬虫？ 爬虫一般指网络爬虫，是一种按照一定的规则，自动的抓取万维网信息的程序或脚本 如何去写一个爬虫？ ==3==：!Doctype的作用： Doctype是document type的简写，声明叫做文件类型定义（DTD），声明的作用是为了告诉浏览器该文件的类型，让浏览器解析器知道用哪个规范来解析文档，!Doctype必须放在HTML文档的第一行，它不是一个HTML标签 严格模式和混杂模式的区别以及如何触发两种模式 严格模式：又称为标准模式，是指浏览器按照W3C标准解析代码 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码 区别：浏览器解析时到底使用严格模式还是混杂模式，与网页中的DTD相关 1.如果文档包含严格的DOCTYPE，那么它一般以严格模式呈现。（严格DTD——严格模式） 2.包含过渡DTD和URL的DOCTYPE，也以严格模式呈现，但有过渡DTD而没有URL（统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有URL的过渡DTD——严格模式；没有URL的过渡DTD——混杂模式） 3.DOCTYPE不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式） 4.HTML5没有DTD，因此也就没有严格模式与混杂模式的区别，HTML5有相对宽松得语法，实现时，已经尽可能大的实现了向后兼容。（HTML没有严格与混杂之分） ==4：==.DOM树 什么是DOM? DOM是Document Object Model（文档对象模型）的缩写，是W3C的标准，它定义了访问HTML和XML文档的标准：“W3C文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。” W3C DOM标准被分为3个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对XML文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 什么是HTML DOM？ HTML DOM 是： HTML 的标准对象模型 HTML 的标准编程接口 W3C 标准 HTML DOM定义了所有HTML元素的对象和属性，以及访问它们的方法。 换言之，HTML DOM是关于如何获取、修改、添加或删除HTML元素的标准 如何去优化DOM结构？ 1把DOM和Javascript各自想象成一个岛屿，它们之间用收费桥梁连接 因此要避免去操作DOM，还要减少去访问DOM的次数。 ==5==.标签嵌套规则及HTML转义 1.块级元素 div、h1~h6、address、blockquote、center、dir、dl、dt、dd、fieldset、form、hr、isindex、menu、nooframes、noscript、ol、p、pre、table、ul... 特点：总是在新行上开始，高度、行高以及顶和底边距都可控制，宽度缺省是它的容器的100%，除非设定一个宽度 功能：主要用来搭建网站架构、页面布局、承载内容 2.行内元素 span、a、abbr、acronym、b、bdo、big、br、cite、code、dfn、em、font、i、img、input、kbd、label、q、s、samp、select、small、strike、strong、sub、sup、textarea、tt、u、var ... 特点：和其他元素都在一行上，高、行高及顶和底边距不可改变，宽度就是它的文字或图片的宽度，不可改变 功能：用于加强内容显示,控制细节，例如：加粗、斜体等等 HTML转义","categories":[],"tags":[]},{"title":"swiper入门学习","slug":"swiper入门学习","date":"2018-01-21T16:57:30.000Z","updated":"2018-01-21T17:46:45.000Z","comments":true,"path":"2018/01/22/swiper入门学习/","link":"","permalink":"http://yoursite.com/2018/01/22/swiper入门学习/","excerpt":"","text":"什么是swiper？swiper是一种用于移动端页面的前端特效插件，它是一种纯javascript的框架，主要用来做轮播图之类页面，在使用之前首先我们需要下载swiper 注：下载swiper-4.1.0.min.js和swiper-4.1.0.min.css即可 swiper使用方法1.首先加载插件1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ... &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/swiper.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; ... &lt;script src=&quot;path/to/swiper.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.HTML内容1234567891011121314151617&lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt;&lt;/div&gt;导航等组件可以放在container之外 注：可以自行给swiper定义大小 3.初始化swiper1234567891011121314151617181920212223&lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, &#123; direction: &apos;vertical&apos;, loop: true, // 如果需要分页器 pagination: &#123; el: &apos;.swiper-pagination&apos;, &#125;, // 如果需要前进后退按钮 navigation: &#123; nextEl: &apos;.swiper-button-next&apos;, prevEl: &apos;.swiper-button-prev&apos;, &#125;, // 如果需要滚动条 scrollbar: &#123; el: &apos;.swiper-scrollbar&apos;, &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 4.如何利用swiper实现一个简单的轮播图效果 默认前三项都成功完成 首先先上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;swiper-4.1.0.min.css&quot;&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .swiper-container &#123; width: 600px; height: 300px; &#125; .swiper-slide&#123; font-size: 50px; &#125; .swiper-slide:nth-of-type(1)&#123; background-color: cornflowerblue; &#125; .swiper-slide:nth-of-type(2)&#123; background-color: coral; &#125; .swiper-slide:nth-of-type(3)&#123; background-color: yellowgreen; &#125; .swiper-slide:nth-of-type(4)&#123; background-color: coral; &#125; .swiper-slide:nth-of-type(5)&#123; background-color: cornflowerblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 3&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 4&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;swiper-4.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, &#123;// horizontal 水平 // vertical 垂直 direction: &apos;horizontal&apos;,// 开始显示第几张 initialSlide: 0,// 换页速度 speed: 1500,// 自动切换 autoplay: &#123; delay: 2000, &#125;, &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; initialSlide参数：设定初始化时slide页面的索引，初始时为0，即默认为轮播图第一张图；如果设置为2时，swiper初始化时页面就是轮播图第三张图 direction参数：设置轮播图的滑动方向，水平方向为（horizontal），垂直方向为（vertical），默认为水平方向 speed参数：轮播图的切换速度 autoplay参数：设置为true时自动切换图片，默认为false delay参数：自动切换的时间间隔，详情见上图代码 关于swiper的用法和初始化组件还有许多，具体请查看swiperAPI文档","categories":[],"tags":[]},{"title":"webpack入门学习","slug":"webpack入门学习","date":"2018-01-08T02:14:35.000Z","updated":"2018-01-08T02:26:07.181Z","comments":true,"path":"2018/01/08/webpack入门学习/","link":"","permalink":"http://yoursite.com/2018/01/08/webpack入门学习/","excerpt":"","text":"什么是Webpack?Webpack是一个前端资源加载/打包工具，它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源. 通俗地讲，Webpack可以看作是模块打包机：它做的事情是，分析你的项目结构，找到Javascript模块以及其他的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 Webpack与Gulp区别Webpack与之前学习的gulp相比较而言，两者的流程不大相同，而且Wwbpack的处理速度更快更直接，能打包更多不同类型的文件。 gulp是一种能够优化前端的开发流程的工具，它的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。 Webpack是一种模块化的解决方案，它的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的Javascript文件。 【注:loader用于对模块的源代码进行转换,比如Webpack只能处理js文件，因此对于css文件就需要安装对应loader模块：style-loader和css-loader等】 从图中可以看出，Webpack可以将多种静态资源js,css,less转换成一个静态文件。 使用Webpack安装Webpack在安装之前，需要检查本地环境是否支持node.js 使用npm安装Webpack 1npm install webpack -g 创建一个文件夹在你的电脑随便一个盘里创建一个新的文件夹或者使用命令创建: 1mkdir webpack-test 在文件夹中新建一个run1.js文件，代码如下： 1document.write(&quot;Hello World&quot;); 再添加index.html文件，代码如下： 12345678&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt; &lt;/body&gt;&lt;/html&gt; 接下来使用Webpack命令进行打包： 1webpack run1.js bundle.js 执行以上命令会编译run1.js文件并生成bundle.js文件 在浏览器中打开index.html文件，会看到页面上有“Hello World”。 Loader就像之前说的，如果想要处理除js之外的其他文件，对于css文件，首先需要执行命令来安装css-loader和style-loader 1npm install css-loader style-loader 接下来创建一个style.css文件，代码如下： 123body&#123; background:red;&#125; 修改run1.js文件： 12require(&quot;!style-loader!css-loader!./style.css&quot;);document.write(&quot;Hello World&quot;); 继续使用Webpack命令打包： 1webpack run1.js bundle.js 在浏览器访问index.html会发现背景变成红色。 配置文件可以将一些编译选项放在配置文件中，以便于统一管理。 创建webpack.config.js文件 123456789101112module.exports = &#123; entry: &quot;./run1.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/,loader: &quot;style.loader!css-loader&quot;&#125; ] &#125;&#125;; 接下来只需要执行webpack命令即可生成bundle.js文件 Webpack命令执行后，会默认载入当前目录的webpack.config.js文件。 当你想要查看你添加的loaders模块时。可以在安装webpack之后再生成一个package.json文件,它里面会显示你当前所有的依赖模块，代码如下： 1npm init 默认一直点回车就行 开发环境如果不想每次修改模块之后还要重新编译，那么可以启用监听模式；开启之后，就不需要每次都重新编译，代码如下： 1webpack --watch 当然还有一种方法是启用一个本地服务器，来实现热加载，可以使用webpack-dev-server服务，当然首先需要安装： 1npm install webpack-dev-server -g 运行： 1webpack-dev-server 运行之后一般会通过localhost:8080启用一个express静态资源web服务器，并且会以监听模式自动运行webpack；如果该端口被占用，可以通过“ -port 端口号 ” 来改变服务器端口。 当然webpack还有其他功能，我也还在学习当中。","categories":[],"tags":[]},{"title":"npm学习","slug":"npm学习","date":"2017-12-30T07:18:22.000Z","updated":"2018-01-02T12:25:46.139Z","comments":true,"path":"2017/12/30/npm学习/","link":"","permalink":"http://yoursite.com/2017/12/30/npm学习/","excerpt":"","text":"什么是npm？它有什么作用？ npm是和node.js一起的包管理工具，并且在安装node.js时已经安装好了npm,npm常见的使用场景有以下几个: 1231.允许用户从npm服务器下载别人编写的第三方包到本地使用。2.允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。3.允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。 安装npm npm本地安装的命令为: 1npm install npm 全局安装的命令为: 1npm install npm -g 如果要检查是否安装成功可以输入命令行: 1npm -v 来测试是否安装成功。 使用package.jsonpackage.json位于模块的目录下，用于定义包的属性。 在当前目录下产生package.json文件1npm init 安装当前package,json中定义的模块1npm install 注册与提交注册用户1234npm adduserUsername:输入用户名Password:输入密码Email:输入邮箱 编写完模块后输入命令行:1npm publish #发表模块 更新模块 尽管node.js自带pm，但是如果想要更新npm的话。可以输入命令: 1npm update npm -g 搜索模块1npm search &quot;Module Name&quot;","categories":[],"tags":[]},{"title":"gulp学习","slug":"gulp学习","date":"2017-12-28T11:05:28.000Z","updated":"2018-01-02T12:25:49.889Z","comments":true,"path":"2017/12/28/gulp学习/","link":"","permalink":"http://yoursite.com/2017/12/28/gulp学习/","excerpt":"","text":"gulp作为前端开发过程中对代码进行构建的工具，对它进行了解学习是必要的，它可以提高我们的学习和工作效率 要使用gulp，首先要明白它是基于node.js下运行的，所以我们需要先安装node.js，安装完成后再安装gulp，这里分为全局安装gulp与本地安装gulp：对于全局安装，它的目的是为了通过它执行gulp任务;安装的命令提示符是： 1npm install gulp -g 安装好之后，可以使用 1gulp -v 来进行验证，如果出现版本号即为正确安装 而本地安装只需要将”-g”去掉 1npm install gulp 安装完成之后我们需要新建一个package,json文件 说明：package.json是基于node.js项目必不可少的配置文件，它是存放在项目根目录的json文件(在之后的gulpfile.js编写中也可以当做检查gulp插件是否调入的判断)安装的命令提示符 1npm init 这里需要说明一下package.json文件里的内容 123456789101.name:项目名称2.version:版本号3.description:项目描述4.homepage:项目网站5.author:作者姓名6.contributors:其他相关人姓名7.dependencies:包(插件)列表，默认在node_modules目录下8.repository:包(插件)存放地方的类型，可以是git或svn,git可在GitHub上9.main:main字段指定了程序的主入口文件，require(&apos;moduleName&apos;)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js10.keywords:关键字 在gulp里面的主要知识点我个人认为是在于写gulpfile.js文件举例说明 123456var sass = require(&apos;gulp-sass&apos;); //将插件导入文件中并命名gulp.task(&apos;sass&apos;,function()&#123; //定义一个匿名函数return gulp.src(&apos;stylesheets/**/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); gulp.src() –找出需要处理的文件 .pipe() –指定需要执行的功能 gulp.desk() –将处理好的文件放到指定的位置 像例子中的sass就是一个插件，它的功能是将文件变为.css格式的文件,安装方式是 1npm install gulp-sass --save-dev 其他插件的安装方式与用法基本类似,不多描述 下面是我对gulp中的几个API的理解1.gulp.src()利用这个方法可以读取你需要的文件，语法为:1gulp.src(globs[,optios]) globs参数是文件匹配模式，用来匹配文件路径；当有多个模式时，该参数为一个数组；options为可选参数，通常用不到 2.gulp.dest()用来写文件，其语法为:1gulp.dest(path[,optios]) path为写入文件的路径；options为可选参数，通常用不到 3.gulp.task()用来定义任务，语法为:1gulp.task(name[,deps],fn) name为任务名；deps是当前定义的任务需要依赖其他任务；fn为任务函数，任务要执行的代码写在里面 4.gulp.watch()用来监视文件的变化，当文件发生变化后，可以利用它来执行相应的任务,语法为:1gulp.watch(glob[,opta],tasks) glob为要监视的文件匹配模式；opts为一个可选的配置对象，通常不用；tasks为文件变化后要执行的任务，为一个数组","categories":[],"tags":[]},{"title":"Git学习","slug":"git学习","date":"2017-12-26T06:42:13.000Z","updated":"2018-01-02T12:25:52.179Z","comments":true,"path":"2017/12/26/git学习/","link":"","permalink":"http://yoursite.com/2017/12/26/git学习/","excerpt":"","text":"什么是Git？Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理，而对于大家熟知的Github来说，它是一个用Git做版本控制的项目托管平台如图： 在这里我把我学习Git过程中的知识总结出来，供大家参考 要想使用Git，首先我们需要来安装Git，这里我把链接放在这，有兴趣的兄dei可以来下载安装链接 密码：ue9y 下载好之后，我们就开始正式了解Git 因为在建博客时也用到了Git，因此我主要说明一下Git如何进行远程连接和下载提交工程要使用Git，我们首先要告诉Git我们是谁一般填写的都是Github的用户名和注册邮箱 1git config --global user.name &apos;你的名称&apos; 1git config --global user.email &apos;你的邮箱&apos; 初始化在任意一个地方新建一个文件，然后在文件中打开git，输入初始化命令 1git init 即初始化完成 提交过程首先我们需要先查看当前文件的状态 1git status 它会显示出当前我们所在的分支，比如“on branch master”表示我们现在处在master这个分支上，即主分支 当我们在文件中新建文件之后，再次运行“git status”时，结果会以红色字体出现新建文件名，即git未跟踪文件，现在我们需要将未跟踪文件添加进来，输入 1git add . #表示添加所有修改文件 或1git add 文件名 #表示添加某一文件 再次运行“git status”，会显示绿色字体，表示该文件将要被提交，这时需要确认提交 1git commit -m &apos;提交信息&apos; #提交信息主要写你提交了什么文件 提交完成 注：一旦修改了跟踪文件的内容，就要重新进行提交 创建分支先查看所有分支 1git branch 分支名称左边有“*”的默认为当前分支 创建分支 1git branch 分支名 既然分支创建好了，如何切换分支呢？我们需要输入命令 1git checkout 分支名 下载版本库1git clone 远程版本库地址 #默认名称为版本库名称，可以在后面加上自定义的名称 下载完成后，就可以在本地对版本库进行修改 提交版本库当修改完成之后，在git里面输入1git push origin master 完成提交 但是远程版本库并不知道你已经更新了状态，这个时候我们需要输入 1git fetch 提示已经提取到更新，然后查看状态 1git status 查看显示远程上已经有了更新，然后我们需要进行 1git merge origin/master 这个时候当前分支就与“master”分支保持一致了","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2017-12-25T14:13:47.000Z","updated":"2017-12-25T15:03:55.311Z","comments":true,"path":"2017/12/25/第一篇博客/","link":"","permalink":"http://yoursite.com/2017/12/25/第一篇博客/","excerpt":"","text":"经历千辛万苦，我终于建好了我的个人博客，期间在网上翻看了不少前辈的教程和方法，也选择了各种建造博客的工具，最后还是使用最顺手的一个来用了，我的博客主要是分享学习新知识的总结和理解，以及生活中的一些有趣的故事，说来惭愧，小白我虽然学习的是前端，但也有那么一丢丢文学细胞，也想通过自己写的文章来让别人感受到不同的自己，今后会不定时更新的哦","categories":[],"tags":[]}]}