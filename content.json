{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-06-11T07:13:06.000Z","updated":"2019-07-12T05:29:19.116Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-16T09:32:49.000Z","updated":"2019-07-16T09:46:32.485Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"tj前端项目部署流程","slug":"tj前端项目开发部署流程","date":"2019-07-15T10:54:45.000Z","updated":"2019-07-16T12:59:48.151Z","comments":true,"path":"2019/07/15/tj前端项目开发部署流程/","link":"","permalink":"http://yoursite.com/2019/07/15/tj前端项目开发部署流程/","excerpt":"","text":"修改于2019.07.16 20:51:21 根据PMO确认排期和进入开发时间，进行开发（注意更改PMO状态） 从master上新建开发分支，命名规则 123示例：项目 feature-190716-PT-12151-telephone-jiahuancbug hotfix-190716-PT-12151-telephone-jiahuanc 修改代码，提交到开发分支 12345678910示例：git checkout mastergit pullgit checkout workbranchgit statusgit add .git commit -m &quot;xxxxx&quot;git push origin workbranch进入gitlab进行 merge request并检查是否有冲突（解决冲突） 进行测试之前需要自己review检查，完成之后进行交叉review，先找同一项目同事进行交叉diff，邮件收到review done 之后需要在组内提diff，艾特技术负责人进行review，review done才可以上线；若review未通过，需要修改重新提diff（首次发群里，第二次只发技术负责人） 上线需要在大群里申请上线【邮件收到两个review done才可以上线】 上线完成之后需要进行回溯检查 123456示例：申请diff：途家品牌名称变更为途家民宿 mobpmo：http://pmo.tujia.com/browse/PT-15838diff：http://gitlab.corp.tujia.com/h5/fetujia_mob/merge_requests/194/diffs@技术负责人 123456示例：申请上线：途家品牌名称变更为途家民宿 mobpmo：http://pmo.tujia.com/browse/PT-15838diff：http://gitlab.corp.tujia.com/h5/fetujia_mob/merge_requests/194/diffs上线时间：填写日期 测试：测试人员 注： 项目进行提测的时候需要及时更改PMO状态，及时和测试沟通解决出现的bug，尽量做到当天发现当天改，避免不必要的问题。 选择部署的测试环境需要和测试同学沟通，确定测试分支。 当天上线一定要当天在群里发上线通知，一旦上线代码不可修改，为了减少麻烦一定要细心修改提交。","categories":[],"tags":[{"name":"tj","slug":"tj","permalink":"http://yoursite.com/tags/tj/"}]},{"title":"Git学习【更新】","slug":"Git学习【持续更新】","date":"2019-07-11T09:48:24.000Z","updated":"2019-07-16T09:56:51.450Z","comments":true,"path":"2019/07/11/Git学习【持续更新】/","link":"","permalink":"http://yoursite.com/2019/07/11/Git学习【持续更新】/","excerpt":"","text":"什么是Git？ Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理，而对于大家熟知的Github来说，它是一个用Git做版本控制的项目托管平台如图： 在这里我把我学习Git过程中的知识总结出来，供大家参考 要想使用Git，首先我们需要来安装Git，这里我把链接放在这，有兴趣的兄dei可以来下载安装链接 密码：ue9y 下载好之后，我们就开始正式了解Git 因为在建博客时也用到了Git，因此我主要说明一下Git如何进行远程连接和下载提交工程要使用Git，我们首先要告诉Git我们是谁一般填写的都是Github的用户名和注册邮箱 1git config --global user.name &apos;你的名称&apos; 1git config --global user.email &apos;你的邮箱&apos; 初始化在任意一个地方新建一个文件，然后在文件中打开git，输入初始化命令 1git init 即初始化完成 提交过程首先我们需要先查看当前文件的状态 1git status 它会显示出当前我们所在的分支，比如“on branch master”表示我们现在处在master这个分支上，即主分支 当我们在文件中新建文件之后，再次运行“git status”时，结果会以红色字体出现新建文件名，即git未跟踪文件，现在我们需要将未跟踪文件添加进来，输入 1git add . #表示添加所有修改文件 或1git add 文件名 #表示添加某一文件 再次运行“git status”，会显示绿色字体，表示该文件将要被提交，这时需要确认提交 1git commit -m &apos;提交信息&apos; #提交信息主要写你提交了什么文件 提交完成 注：一旦修改了跟踪文件的内容，就要重新进行提交 创建分支先查看所有分支 1git branch 分支名称左边有“*”的默认为当前分支 创建分支 1git branch 分支名 既然分支创建好了，如何切换分支呢？我们需要输入命令 1git checkout 分支名 下载版本库1git clone 远程版本库地址 #默认名称为版本库名称，可以在后面加上自定义的名称 下载完成后，就可以在本地对版本库进行修改 提交版本库当修改完成之后，在git里面输入1git push origin master 完成提交 但是远程版本库并不知道你已经更新了状态，这个时候我们需要输入 1git fetch 提示已经提取到更新，然后查看状态 1git status 查看显示远程上已经有了更新，然后我们需要进行 1git merge origin/master 这个时候当前分支就与“master”分支保持一致了 以上 2017-06-12 分割线 在主分支master上创建子分支（如t1和t2）时，需要注意，创建t1成功后，需要切换回master分支再创建t2分支，这样t1和t2才会是平级的分支。 在工作中使用git进行代码管理时，需要注意公司采用图形化管理还是命令行管理，使用图形化管理时需要注意当前代码需改完成之后，需要进入gitlab下的项目中找到要提交的分支进行merge；命令行合并代码的时候，子分支进行到 git commit -m “xxx” 时就可以切换分支进行合并，然后在主分支进行远程提交即可。 ==另注：使用git一定要小心== 更新于 2019-07-11","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"H5项目理解【持续更新】","slug":"途家H5站点初步理解","date":"2019-07-11T08:26:23.000Z","updated":"2019-07-16T09:56:41.006Z","comments":true,"path":"2019/07/11/途家H5站点初步理解/","link":"","permalink":"http://yoursite.com/2019/07/11/途家H5站点初步理解/","excerpt":"","text":"fetujia_mob ==home==app下载 tjheader 由tujia-logo和右侧tjMenu组件组成，tjMenu组件内容包含在npm包。 Search 点击输入框跳转到列表页，点击后会获取目的地和关键词数据 我的途家[点击跳转到vip] 点击后进行登录判断，未登录跳转到登录页面，已登录可查看个人信息页面 我的订单[点击跳转到vip] 点击后进行登录判断，未登录跳转到登录页面，已登录可查看当前账户所有订单 领红包[点击跳转到PWA] 点击“立即抢”跳转到PWA活动页面，活动页面点击“立即领取”会判断是否登录，未登录跳转到登录页面，已登录显示领取成功提示，再次点击“立即领取”会跳转到列表页 精选主题 点击图片跳转到PWA页面 点击页面里的“一键领取”会判断是否登录，未登录跳转到登录页面，已登录显示“领取成功提示”，再次点击跳转到列表页 点击页面的房屋信息会跳转到列表页 发现公寓 点击图片跳转到详情页，点击右上角“收藏”会判断是否登录，未登录跳转到登录页面，已登录会收藏房屋信息 footer[除“关于途家”，其他跳转均为PWA] ==list==tjHeader filterBar list 点击列表内容跳转到详情页。点击图片跳转到详情页，点击右上角“收藏”会判断是否登录，未登录跳转到登录页面，已登录会收藏房屋信息 ==detail==房屋信息 房屋图片 房屋名称、用户评价 特色标签 连住优惠 房屋厅室 房屋位置 房屋详情 设施服务 可租日期 交易规则 入住须知 额外费用 周边相似房屋 底部栏 聊天+电话+下单： 点击“聊天”判断是否登录，未登录跳转到登录页面，已登录跳转到chat页面 点击“电话”判断是否登录，未登录跳转到登录页面，已登录跳转到呼叫房东页面，此页面有支持分时段服务电话业务接口 点击“立即预定”判断是否登录，未登录跳转到登录页面，已登录跳转到填单页并获取填单页数据，下单按钮有接口熔断机制处理。 ==Order==填写订单信息后点击提交订单跳转到订单详情页（非fetujia_mob项目页）","categories":[],"tags":[{"name":"h5","slug":"h5","permalink":"http://yoursite.com/tags/h5/"}]},{"title":"vue问题总结【更新】","slug":"vue问题总结【持续更新】","date":"2018-08-22T13:06:55.000Z","updated":"2019-07-16T09:57:16.582Z","comments":true,"path":"2018/08/22/vue问题总结【持续更新】/","link":"","permalink":"http://yoursite.com/2018/08/22/vue问题总结【持续更新】/","excerpt":"","text":"1、今天在公司修改样式的时候发现引入Element-UI的tooltip组件之后，想对tootip的样式进行自定义修改，结果发现无论怎么设置选择器的优先级，都渲染不到页面上，后来经过一系列的尝试之后发现是由于给style设置scoped造成的，本身设置scoped是为了防止全局样式冲突，结果没想到会造成自定义的样式渲染不上，后来经过思考测试，其实是可以将组件内修改tooltp的样式放到全局css中，不过需要给对应的元素设置类型，比如tooltip可以通过popper-class=”tooltip”设置类名，然后给这个类名添加样式。 2、在进行vue页面编写时经常会用到数据绑定，在渲染页面的时候其实会出现页面闪烁会看到变量的问题，比如通过&lt;p&gt;&lt;p&gt;进行数据绑定，页面刷新时可能会看到，这对于用户体验来说是很差的，因此我们可以使用v-clock来解决这个问题，基本上我们只需要把它添加到el挂载的标签就可以，一般来说就是最外层的div，如&lt;div class=”#app” v-clock&gt; 在某些情况下v-clock并不起作用 ①、挂载v-clock的元素的display属性被更高层级的覆盖掉了，如!important属性，这就需要我们提高层级 ②、当样式放到@import引入的css文件中时v-clock是不起作用的，可以用link引入样式或者写入内联样式。 3、在搭建个人博客时我曾经换过页面标题旁边的图标，因此在利用vue编写个人项目时也考虑过这个问题，它的实现思路和博客其实差不多，只需要在最外层index.html的head标签里面加上&lt;link rel=”shortcut icon” type=”image/x-icon” href=”static/favicon.ico”&gt;，个人建议图标和logo之类的图片放在static文件夹中比较好。 to be continue…","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"利用hover控制其他元素样式","slug":"利用hover控制其他元素样式","date":"2018-08-21T13:05:29.000Z","updated":"2019-07-16T09:56:30.411Z","comments":true,"path":"2018/08/21/利用hover控制其他元素样式/","link":"","permalink":"http://yoursite.com/2018/08/21/利用hover控制其他元素样式/","excerpt":"","text":"之前在项目中有一个需求是鼠标移入元素上时该元素改变样式的同时另外元素样式也要改变，刚开始想利用js来实现，不过有点麻烦，之后发现可以通过css直接来实现这个功能，本着人无我有，人有我优的原则，在这里记录一下具体过程。 首先我经过尝试以及网上查找之后，发现利用hover来实现这个功能是有一定局限性的，如果你要改变其他元素的样式，那么它们必须是相邻同级元素或者是同一父元素的子元素，不然效果是出不来的（呜~） 相邻同级元素HTML &lt;div class=\"div1\"&gt; &lt;div class=\"son1\"&gt;son1 &lt;/div&gt; &lt;div class=\"son2\"&gt;son2 &lt;/div&gt; &lt;/div&gt; CSS .son1 , .son2{ width:100px; height:100px; border:1px solid #000; } .son1:hover + .son2{ background:#000; } 鼠标移入son1元素，son2元素背景色变黑 父级元素HTML &lt;div class=\"div1\"&gt; &lt;div class=\"son\"&gt;son1 &lt;/div&gt; &lt;/div&gt; CSS .div1{ width:200px; height:200px; border:1px solid #000; } .son{ margin:0 auto; width:100px; height:100px; border:1px solid #000; } .div1:hover .son{ background:#000; } 鼠标移入父级.div1元素，子元素son背景变黑","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Web安全攻击方式","slug":"Web安全攻击方式","date":"2018-05-18T15:56:27.000Z","updated":"2019-07-16T09:57:25.243Z","comments":true,"path":"2018/05/18/Web安全攻击方式/","link":"","permalink":"http://yoursite.com/2018/05/18/Web安全攻击方式/","excerpt":"","text":"xssxss是跨站脚本攻击，指攻击者在网页中嵌入客户端脚本，当用户浏览次页面时，脚本就会在用户浏览器上执行，从而达到攻击目的 比如我们下载有这么一个代码 &lt;input type=”text” name=”address” value=”valuefrom”&gt; valuefrom是来自用户的输入，如果用户不是输入valuefrom而是输入”/&gt;&lt;script&gt;alert(document.cookie)&gt;/script&gt;&lt;!-,即变成 &lt;input type=”text” name=”address” value=””/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-“&gt; 嵌入的javascript代码将会被执行 xss漏洞修复原则：不要相信用户输入的数据 *注意：攻击代码不一定在&lt;script&gt;&lt;script&gt;标签里 将重要的cookie标记为http only，这样js的document.cookie语句就无法获取cookie 只允许用户输入我们规定的数据，比如年龄只允许输入数字 对数据进行html Encode处理 过滤或移除特殊的html标签，例如&lt;script&gt;,&lt;iframe&gt; 过滤掉js事件的标签，比如onclick,onfocus csrfcsrf是跨站请求伪造，指攻击者盗用了你的身份，以你的名义发送恶意请求，csrf能够以你名义发送邮件，发消息……会造成个人隐私泄露以及财产安全等问题 要完成一次csrf攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成cookie 在不登出A的情况下，访问危险网站B 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生： 1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。 2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……） 3.所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 csrf防御 1.服务端进行csrf防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 (1).Cookie Hashing(所有表单都包含同一个伪随机值) (2).验证码 (3).One-Time Tokens(不同的表单包含一个不同的伪随机值) 目前防御 CSRF 攻击主要有三种策略： ①验证 HTTP Referer 字段； ②在请求地址中添加 token 并验证； ③在 HTTP 头中自定义属性并验证。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"安装mongodb遇到的坑","slug":"安装mongodb遇到的坑","date":"2018-05-11T15:55:45.000Z","updated":"2019-07-16T09:56:23.805Z","comments":true,"path":"2018/05/11/安装mongodb遇到的坑/","link":"","permalink":"http://yoursite.com/2018/05/11/安装mongodb遇到的坑/","excerpt":"","text":"mongodb是一个基于分布式文件存储的开源数据库系统，它主要为WEB应用提供可扩展的高性能数据存储解决方案。下面我说说具体的安装过程 我在官网上下载最新3.6版本并在windows下安装会出现进度条长时间不动的情况，这是因为3.6版本在windows下有不适配的问题，需要我们下载3.4版本安装 （我的安装路径是C:\\Program Files\\MongoDB） 下载安装完成之后，需要添加安装路径到path环境变量：C:\\Program Files\\MongoDB\\Server\\3.4\\bin 我们在D盘创建如下文件夹D:\\mongodb\\data D:\\mongodb\\logs 在命令提示符输入 cd C:\\Program Files\\MongoDB\\Server\\3.4\\bin 再输入mongod.exe –dbpath=D:\\mongodb\\data –logpath=D:\\mongodb\\logs\\mongodb.log –install 输入net start mongodb启动服务 最后在浏览器输入http://localhost:27017/在页面看到It looks like you are trying to access MongoDB over HTTP on the native driver port.表示成功 在这里我说一下我安装的时候遇到的几个坑 1.首先就是安装包问题，需要安装3.4版本的2.在输入net start mongodb之后，提示我服务没有响应控制功能，之后我发现在配置path路径时把C:\\windows\\system32给删掉了，把这句加上就可以了在D盘创建文件夹时，当时看别人的博客是把logs文件夹放到data文件夹里面，我这样操作之后启动服务是无法启动的，当我把logs文件夹和data文件夹并列之后，启动是可以的。","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"使用express配置前端服务器","slug":"使用express配置前端服务器","date":"2018-05-05T13:39:41.000Z","updated":"2019-07-16T09:56:34.292Z","comments":true,"path":"2018/05/05/使用express配置前端服务器/","link":"","permalink":"http://yoursite.com/2018/05/05/使用express配置前端服务器/","excerpt":"","text":"使用webpack打包vue项目之后会生成dist文件夹，dist文件夹下面有html文件和其他的css,js和img等文件，如果你要查看打包之后的文件怎么办，这时候我们可以将生成的dist文件部署到express服务器上运行。 首先我们需要安装express-generator生成器 npm install express-generator -g 创建express项目 express expressname(项目名称) 进入项目目录，安装相关项目依赖 cd expressnamenpm install 将dist文件夹下生成的文件复制到express项目下的piblic文件夹下，然后运行npm start，启动express项目打开浏览器，输入localhost:3000查看效果","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"自适应布局的几种方法","slug":"自适应布局的几种方法","date":"2018-05-01T12:44:19.000Z","updated":"2019-07-16T09:56:47.570Z","comments":true,"path":"2018/05/01/自适应布局的几种方法/","link":"","permalink":"http://yoursite.com/2018/05/01/自适应布局的几种方法/","excerpt":"","text":"自适应布局的几种方法 百分比1&lt;meta name=&quot;viewport&quot; content=&quot;width-device-width,initial-scale=1&quot; viewport是网页默认的宽度和高度，width=device-width即网页宽度默认等于屏幕宽度，initial-scale=1即原始缩放比例为1.0，网页初始大小占屏幕面积的100%。 由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用绝对宽度的元素，如css不能指定像素宽度，只能指定百分比宽度，字体不能使用绝对大小px，而只能使用相对大小em。 @media规则css3的@media规则可以在不改变html内容情况下，根据终端媒体设备的不同选择不同的css样式 具体写法： 123@media 设备类型 and (设备特性)&#123; css样式代码&#125; 例如： //浏览器窗口大于900px @media screen and(min-width:900px){ body{ font-size:25px; } } //浏览器窗口大于500px小于900px @media screen and(min-width:500px)and(max-width:900px){ body{ font-size:20px; } } //浏览器窗口小于500px @media screen and(max-width:500px){ body{ font-size:15px; } } rem自适应布局首先我们需要知道rem是相对于根元素的字体大小的单位，它是一个相对单位，同理em是相对于父元素的字体大小的单位；rem的计算规则依赖根元素，我们只需要在根元素确定一个px字号，就可以计算出元素的宽高。 target-densitydpi属性1&lt;meta name=&quot;viewport&quot; content=&quot;width=640,target-densitydpi=device-dpi,user-scalable=no&quot;&gt; 通过读取device-width的值来自动计算出target-densitydpi去实现自适应网页，不过缺点是目前只在android支持，具有兼容性问题。 target-densitydpi属性的取值范围： device-dpi --使用设备原本的dpi作为目标dpi，不会发生默认缩放。 high-dpi --使用hdpi作为目标dpi，中等像素密度和低像素密度设备相应缩小。 medium-dpi --使用mdpi作为目标dpi，高像素密度设备相应放大，低像素密度设备相应缩小，这是默认的target density low-dpi --使用ldpi作为目标dpi，中等像素密度和高像素密度设备相应放大 value --指定一个具体的dpi，值作为target dpi，这个值得范围必须在70-400之间。","categories":[],"tags":[{"name":"自适应布局","slug":"自适应布局","permalink":"http://yoursite.com/tags/自适应布局/"}]},{"title":"优雅降级与渐进增强","slug":"优雅降级与渐进增强","date":"2018-02-09T14:25:17.000Z","updated":"2019-07-16T09:56:44.308Z","comments":true,"path":"2018/02/09/优雅降级与渐进增强/","link":"","permalink":"http://yoursite.com/2018/02/09/优雅降级与渐进增强/","excerpt":"","text":"优雅降级与渐进增强 优雅降级(Graceful Degradation)：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用CSS3的特性构建了一个应用，然后逐步针对各大浏览器进行测试使其可以再低版本浏览器上正常浏览。 渐进增强(Progressive Enhancement)：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 渐进增强相当于向上兼容，而优雅降级相当于向下兼容，向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少，大多数软件都是向下兼容的 区别 优雅降级认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段 渐进增强则认为应关注于内容本身，而对浏览器则是次要的，因为内容是建立网站的诱因，这使得渐进增强成一种更为合理的设计范例。 例：123456789101112.transition&#123; /*渐进式写法*/ -webkit-transition:all .5s; -moz-transition:all .5s; -o-transition:all .5s; transition:all .5s;&#125;.transition&#123; /*优雅降级写法*/ transition:all .5s; -o-transition:all .5s; -moz-transition:all .5s; -webkit-transition:all .5s;&#125; 前缀CSS3与正常CSS3在浏览器中的支持情况： 很久以前：浏览器前缀CSS3和正常CSS3都不支持； 不久之前：浏览器只支持前缀CSS3，不支持正常CSS3； 现在：浏览器既支持前缀CSS3，又支持正常CSS3； 未来：浏览器不支持前缀CSS3，仅支持正常CSS3。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"了解Vue-router","slug":"了解Vue-router","date":"2018-02-06T17:30:11.000Z","updated":"2019-07-16T09:56:27.070Z","comments":true,"path":"2018/02/07/了解Vue-router/","link":"","permalink":"http://yoursite.com/2018/02/07/了解Vue-router/","excerpt":"","text":"Vue-router通过Vue我们可以实现组件化开发，而各组件之间如何跳转呢，在我们第一次项目用gulp构建工具开发时，页面跳转是通过a标签的href属性实现的，不过在Vue中，页面跳转是通过路由实现的，路由的配置就成了一个需要学习的问题 路由实现页面跳转首先需要安装插件 npm install vue-router –save 之后在 main.js 里面写入 import VueRouter from ‘vue-router’ Vue.use(VueRouter) 通过它来引入 vue-router ，之后进入 /router/index.js 文件，同样先引入 import Router from ‘vue-router’ Vue.use(Router) 然后将你需要进行跳转的组件引入这个文件中，比如我现在要进行首页(index.vue)与商品列表(goodlist.vue)的跳转,首先我们需要将这两个页面引进来 import index from ‘@/components/index.vue’ import goodlist from ‘@/components/goodlist/goodlist.vue’ 然后进行页面的配置 12345678910111213141516export default new Router(&#123; routers: [ &#123; title: &apos;首页&apos;， path: &apos;/&apos;, name: &apos;index&apos;, components: index &#125;, &#123; title: &apos;商品目录&apos;, path: &apos;/goodlist&apos;, name: &apos;goodlist&apos;, components: goodlist &#125; ]&#125;) 然后在你的index.vue中商品元素的父元素中写入点击事件 &lt;span @click=”goodlist()”&gt;商品目录&lt;/span&gt; 然后在script中写入 1234567export default &#123; methods: &#123; goodlist: function () &#123; this.$router.push(&#123;path: &apos;/goodlist&apos;&#125;) &#125; &#125;&#125; 之后在页面点击首页的商品就可以跳转到商品列表页面","categories":[],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"http://yoursite.com/tags/vue-router/"}]},{"title":"PWA了解【更新】","slug":"PWA了解","date":"2018-02-05T17:07:11.000Z","updated":"2019-07-16T09:57:02.054Z","comments":true,"path":"2018/02/06/PWA了解/","link":"","permalink":"http://yoursite.com/2018/02/06/PWA了解/","excerpt":"","text":"分享总结Progressive Web App这个词直译就是“进步的web app”，由于学长推荐的学习网页需要翻墙才能看，我在这里给大家推荐另一个网站 什么是PWA,希望能有所帮助 什么是PWA？PWA是一种提升Web App体验的方法，能带给用户原生应用般的体验，而PWA的主要特点主要包含以下几点： 渐进式 - 适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的 自适应 - 适合任何机型：桌面设备、移动设备、平板电脑等 连接无关性 - 能够借助服务工作线程在离线或低质量网络状况下工作 类似应用 - 由于是在 App Shell模型 基础上开发，因此具有应用风格的交互和导航，给用户以应用般的熟悉感 持续更新 - 在服务工作线程更新进程的作用下时刻保持最新状态 安全 - 通过HTTPS提供，以防止窥探和确保内容不被篡改 可发现 - W3C清单和服务工作流程注册作用域能够让搜索引擎找到它们，从而将其识别为“应用” 可再互动 - 通过推送通知之类的功能简化了再互动 可安装 - 用户可免去使用应用商店的麻烦，直接将对其最有用的应用“保留”在主屏幕上 可链接 - 可通过网址轻松分享，无需复杂的安装 比如有一个具体的例子，天气PWA，当我们平时遇到断网时刷新一下页面，电脑或手机会出现“未连接到互联网”之类的页面或错误提示，而PWA则会在断网刷新后依然出现页面内容，而且当我们对页面上一个内容很感兴趣时，我们可以直接将它放在主页面，不需要安装app,国内的 豆瓣网手机版 使用的也是PWA，对于如何使用，由于在chrome浏览器需要下载“Web Server for Chrome”扩展功能，我们可以查按照我推荐的那个网站来进行操作 Service Worker前端工程师有很多性能优化手段，包括CDN、CSS Sprite、文件的合并压缩、异步加载、资源缓存等（原谅我还不清楚具体的性能优化），而Service Worker让缓存做到了优雅、极致，让Web App的缺点更加弱化。 Service Worker特点： 一个独立的worker线程，独立于当前网页进程，有自己独立的worker context 一旦被install，就永远存在，除非被uninstall 需要时可直接唤醒、不需要要=可以自动睡眠‘ 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程渠取到（包括离线状态） 离线内容开发者可控 能向客户端推送消息 不能直接操作DOM 必须在HTTPS环境下工作 异步实现，内部大都是通过Promise实现 如何使用Service Worker请看网站资源，我试过，不用翻墙，可以成功检查到是否安装Seivice Worker","categories":[],"tags":[{"name":"pwa","slug":"pwa","permalink":"http://yoursite.com/tags/pwa/"}]},{"title":"Vue中外链css和js【不推荐引】","slug":"vue中如何引入外链css和js","date":"2018-01-30T19:10:29.000Z","updated":"2019-07-16T09:57:20.244Z","comments":true,"path":"2018/01/31/vue中如何引入外链css和js/","link":"","permalink":"http://yoursite.com/2018/01/31/vue中如何引入外链css和js/","excerpt":"","text":"初次使用vue，在这里我把我了解到的vue如何引入css和js方法给大家分享一下 引入外链css 大家的文件夹格式基本都是 这样的吧，在这里，我建议大家把css文件都放在static文件夹里面，可以直接放，也可以在里面新建文件夹放入，我也不知道为什么一定放在这里面，我放在比如assets里面死活就是不出来 放好之后，下面就可以直接在&lt;style&gt;里面引入格式如下： @import ‘./static/common.css’ 这是引入css 而对于js，我主要说一下如何引入jquery 首先我们输入命令行 npm install jquery –save 安装好之后，我们在’build/webpack.base.conf文件中引入jquery 123456789101112module.exports = &#123; ... resolve: &#123; extensions: [&apos;.js&apos;,&apos;.vue&apos;,&apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &apos;jquery&apos;: path.resolve(__dirname, &apos;../node_modules/jquery/src/jquery&apos;) &#125; &#125;, ...&#125; 然后在你需要jquery的地方引入如下方法： import $ from ‘jquery’ 亲测是可以的","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"setTimeout与闭包","slug":"setTimeout与闭包","date":"2018-01-29T17:07:11.000Z","updated":"2019-07-16T09:57:05.913Z","comments":true,"path":"2018/01/30/setTimeout与闭包/","link":"","permalink":"http://yoursite.com/2018/01/30/setTimeout与闭包/","excerpt":"","text":"分享总结今天学姐给我们主要分享了关于setTimeout与闭包的问题，在这里我写一下自己的感受 在这之前，我个人认为首先需要了解一下javascript的单线程和异步。 作为一个脚本语言，javascript的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题，所以也决定了它本身是不可能异步的。 但是，我们通过某种方式又可以使得js具备异步属性，当网络请求、定时器和事件监听时，如果同步执行的话，效率会非常低，所以这时浏览器会开辟另外的线程，主要包括http请求线程，浏览器定时触发器，浏览器事件触发进程，这些都是异步的。 那么问题来了，当异步任务都完成后，主线程又是如何知道的？答案是回调函数，整个程序是事件驱动的，每个事件都会绑定相应的回调函数，例如： 123setTimeout(function()&#123; console.log(time is out);&#125;,50); 当执行这段函数时，浏览器异步执行计时操作，当50ms时，会触发定时事件，这个时候就会把回调函数放到任务队列里 所以，js一直都是单线程的，浏览器实现异步 下面我们主要来回顾一下学姐今天给我们讲的知识： 1、setTimeout(f1,0) 这个语句中的f1数是立刻执行的吗？并不一定，我们首先要知道主线程内的命令是否执行完，如： 1234setTimeout(function()&#123; console.log(1);&#125;,0)console.log(2); 这段代码输出为2,1，因为执行setTimeout后，会立即把匿名函数放到任务队列里面等待主线程召唤，等到执行完console.log(2)之后，才会执行匿名函数，这里有人会问为什么要用setTimeout(f1,0)语句，首先我们要确认这个语句是具有意义的：如果f1很费时，那么我们需要先将它放到任务队列里面，等到主程序执行完之后再执行f1。 2、setTimeout中的闭包 12345for(var i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,1000*i);&#125; 结果：开始打印一个5，然后每隔一秒输出5，总共5个5 解析：先执行setTimeout外面的函数，然后执行setTimeout里面的函数，这时因为for循环已经遍历完，所以i=5，接着执行console.log(i),执行5次，所以输出5个5 那么如何得到0-4呢？ 1234567for(var i = 0;i &lt; 5; i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i); &#125;,i*1000); &#125;)(i);&#125; 结果：每隔一秒输出，输出0-4 解析：在这里我的理解是for循环遍历时，将每次i的值暂时存到(i)里面，然后当执行setTimeout时，通过function(i)将值引入进来，所以输出0-4 删掉i时 1234567for(var i = 0; i &lt; 5; i++)&#123; (function()&#123; setTimeout(function()&#123; console.log(i); &#125;,i*1000); &#125;)(i);&#125; 结果：5个5 解析：个人感觉这样写和第一个语句一样，是通过同样的方式输出。 变： 12345for(var i = 0; i &lt; 5; i++)&#123; setTimeout((function(i)&#123; console.log(i); &#125;)(i),i*1000);&#125; 结果：立刻输出0-4 解析：在这里我个人理解是先打印出0-4，但是先保存，最后一起输出 最后一个 12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 答案是2 3 5 4 1 对于第一个不输出1，我大概理解是它的执行时间是大于0小于1的，所以先执行下面的函数，最后执行setTimeout函数，所以最后打印1（看了mkicrotask和macrotask的区别后，我理解是console(1)会先存入macrotask中，当microtask任务执行完之后，最后执行macrotask任务） 对于es6中的promise方法，这是一种异步解决方法，它有三种状态：pending(进行中)、Resolved(已经完成)和Rejected(已失败)，上面代码里是resolve，是异步操作成功，因此打印出2 当i为9999且resolve()成立时，输出3 promise生成之后，用then方法分别指定Resolved状态和Reject状态的回调函数因此打印4，这块我认为4在5后面的原因是console.log(4)在函数内，执行时会先存入任务队列，然后promise优先级高于setTimeout，所以先输出5，然后是4，最后是1（不知道理解的对不对） 最后，学姐提到了macrotask与microtask,我查看了资料后，显示，它们两个相当于异步任务中不同的两个任务队列 而它们的不同如下： 123456789console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);Promise.resolve().then(function()&#123; console.log(3);&#125;).then(function()&#123; console.log(4);&#125;) 输出是1,3,4,2 由上代码我们就可以看出来（学姐的最后一个代码块也可以看出），Promise的异步任务优先级高于setTimeout的延时为0的任务 原因是Promise的then方法的函数会被存入microtasks队列，而setTimeout函数会被存入marcotasks中 在任务队列中，每一次事件循环，macrotask只会提取一个执行，而microtask会一直提取，直到microtask队列为空，也就是说如果某个microtask推入到执行中，那么当主线程任务完成之后，会循环调用该队列的下一个任务，直到全部完成，而事件循环每次只会引入一个macrotask，执行完之后主线程又会检查microtask队列，完成所有之后再执行macrotask任务","categories":[],"tags":[{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"}]},{"title":"思考跨域问题","slug":"思考跨域问题","date":"2018-01-27T11:31:21.000Z","updated":"2019-07-16T09:56:37.917Z","comments":true,"path":"2018/01/27/思考跨域问题/","link":"","permalink":"http://yoursite.com/2018/01/27/思考跨域问题/","excerpt":"","text":"什么是跨域问题？跨域就是指浏览器不能执行其他网站的脚本，这是由浏览器的同源策略造成的，是javascript的安全限制 一个域名地址是由： http://(请求头) www(子域名) . cuijahuan(主域名) : 8080(端口号) / script/jquery.js(请求资源地址) 组成的 而同源，就是指域名，协议，端口均相同 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域 而不同域之间的相互请求资源，就是跨域比如http://cuijiahuan.xyz 请求 http://jiahuan.xyz 解决方法1、使用ajax的JSONP 首先要了解JSONP只支持GET请求，不支持POST请求 ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性可以访问跨域的js脚本，因此，服务器不再返回JSON格式的数据，而是返回一段调用某个函数的JS代码，在src中进行了调用，实现了跨域。 还没有看jsonp，目前我只知道要在ajax里面引入 type:&quot;get&quot;, // 接收服务器数据的类型 dataType:&quot;jsonp&quot;, // 用于服务器端的获取函数的参数 jsonp:&quot;callback&quot;, // 函数名称 2、使用jquery的jsonp插件 首先我们要引入相关的js文件，相关下载可参考该地址 在我们前端代码中需要在ajax里的url下加入 callbackParameter:&quot;callback&quot; callback:&quot;callback_success&quot; 使用该方法不局限于get请求，还可以是post请求，但从服务器获取到的依然是jsonp格式 第三种方法是使用cors方法，具体可以参考网上其他博客 附：在项目中我解决跨域问题没有用到jsonp，是通过后台修改来实现的，在前端ajax里面需要加上一句语句 xhrFields: {withCredentials: true} 这句是提供了请求发送凭证的支持","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"swiper初步应用","slug":"swiper初步应用","date":"2018-01-21T16:57:30.000Z","updated":"2019-07-16T09:57:09.312Z","comments":true,"path":"2018/01/22/swiper初步应用/","link":"","permalink":"http://yoursite.com/2018/01/22/swiper初步应用/","excerpt":"","text":"什么是swiper？swiper是一种用于移动端页面的前端特效插件，它是一种纯javascript的框架，主要用来做轮播图之类页面，在使用之前首先我们需要下载swiper 注：下载swiper-4.1.0.min.js和swiper-4.1.0.min.css即可 swiper使用方法1.首先加载插件1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ... &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/swiper.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; ... &lt;script src=&quot;path/to/swiper.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.HTML内容1234567891011121314151617&lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt;&lt;/div&gt;导航等组件可以放在container之外 注：可以自行给swiper定义大小 3.初始化swiper1234567891011121314151617181920212223&lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, &#123; direction: &apos;vertical&apos;, loop: true, // 如果需要分页器 pagination: &#123; el: &apos;.swiper-pagination&apos;, &#125;, // 如果需要前进后退按钮 navigation: &#123; nextEl: &apos;.swiper-button-next&apos;, prevEl: &apos;.swiper-button-prev&apos;, &#125;, // 如果需要滚动条 scrollbar: &#123; el: &apos;.swiper-scrollbar&apos;, &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 4.如何利用swiper实现一个简单的轮播图效果 默认前三项都成功完成 首先先上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;swiper-4.1.0.min.css&quot;&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .swiper-container &#123; width: 600px; height: 300px; &#125; .swiper-slide&#123; font-size: 50px; &#125; .swiper-slide:nth-of-type(1)&#123; background-color: cornflowerblue; &#125; .swiper-slide:nth-of-type(2)&#123; background-color: coral; &#125; .swiper-slide:nth-of-type(3)&#123; background-color: yellowgreen; &#125; .swiper-slide:nth-of-type(4)&#123; background-color: coral; &#125; .swiper-slide:nth-of-type(5)&#123; background-color: cornflowerblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 3&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 4&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;swiper-4.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, &#123;// horizontal 水平 // vertical 垂直 direction: &apos;horizontal&apos;,// 开始显示第几张 initialSlide: 0,// 换页速度 speed: 1500,// 自动切换 autoplay: &#123; delay: 2000, &#125;, &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; initialSlide参数：设定初始化时slide页面的索引，初始时为0，即默认为轮播图第一张图；如果设置为2时，swiper初始化时页面就是轮播图第三张图 direction参数：设置轮播图的滑动方向，水平方向为（horizontal），垂直方向为（vertical），默认为水平方向 speed参数：轮播图的切换速度 autoplay参数：设置为true时自动切换图片，默认为false delay参数：自动切换的时间间隔，详情见上图代码 关于swiper的用法和初始化组件还有许多，具体请查看swiperAPI文档 分割线 在vue中我们可以直接下载插件实现swiper的功能 npm install vue-awesome-swiper 然后在main.js中引入 import VueAwesomeSwiper from ‘vue-awesome-swiper’Vue.use(VueAwesomeSwiper) 在对应的 .vue 比如(slide.vue)文件中，写入 12345678910111213141516171819202122232425262728293031323334353637383940template&gt; &lt;div id=&quot;slide&quot;&gt; &lt;swiper :options=&quot;swiperOption&quot; ref=&quot;mySwiper&quot;&gt; &lt;!-- 幻灯内容 --&gt; &lt;swiper-slide&gt;&lt;div class=&quot;fd_slide fd_slide1&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;1.jpg&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/swiper-slide&gt; &lt;swiper-slide&gt;&lt;div class=&quot;fd_slide fd_slide2&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;2.jpg&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/swiper-slide&gt; &lt;swiper-slide&gt;&lt;div class=&quot;fd_slide fd_slide3&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;3.jpg&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/swiper-slide&gt; &lt;swiper-slide&gt;&lt;div class=&quot;fd_slide fd_slide4&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;4.jpg&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/swiper-slide&gt; &lt;swiper-slide&gt;&lt;div class=&quot;fd_slide fd_slide5&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;5.jpg&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; swiper, swiperSlide &#125; from &apos;vue-awesome-swiper&apos;import $ from &apos;jquery&apos;export default &#123; components: &#123; swiper, swiperSlide &#125;, data () &#123; return &#123; swiperOption: &#123; initialSlide: 0, direction: &apos;horizontal&apos;, loop: true, loopAdditionalSlides: 2, speed: 1000, autoplay: &#123; delay: 2000 &#125;, autoplayDisableOnInteraction: false, observer: true, observeParents: true &#125; &#125; &#125; &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"swiper框架","slug":"swiper框架","permalink":"http://yoursite.com/tags/swiper框架/"}]},{"title":"webpack【更新】","slug":"webpack学习【持续更新】","date":"2018-01-08T02:14:35.000Z","updated":"2019-07-16T09:57:28.107Z","comments":true,"path":"2018/01/08/webpack学习【持续更新】/","link":"","permalink":"http://yoursite.com/2018/01/08/webpack学习【持续更新】/","excerpt":"","text":"什么是Webpack?Webpack是一个前端资源加载/打包工具，它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源. 通俗地讲，Webpack可以看作是模块打包机：它做的事情是，分析你的项目结构，找到Javascript模块以及其他的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 Webpack与Gulp区别Webpack与之前学习的gulp相比较而言，两者的流程不大相同，而且Wwbpack的处理速度更快更直接，能打包更多不同类型的文件。 gulp是一种能够优化前端的开发流程的工具，它的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。 Webpack是一种模块化的解决方案，它的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的Javascript文件。 【注:loader用于对模块的源代码进行转换,比如Webpack只能处理js文件，因此对于css文件就需要安装对应loader模块：style-loader和css-loader等】 从图中可以看出，Webpack可以将多种静态资源js,css,less转换成一个静态文件。 使用Webpack安装Webpack在安装之前，需要检查本地环境是否支持node.js 使用npm安装Webpack 1npm install webpack -g 创建一个文件夹在你的电脑随便一个盘里创建一个新的文件夹或者使用命令创建: 1mkdir webpack-test 在文件夹中新建一个run1.js文件，代码如下： 1document.write(&quot;Hello World&quot;); 再添加index.html文件，代码如下： 12345678&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt; &lt;/body&gt;&lt;/html&gt; 接下来使用Webpack命令进行打包： 1webpack run1.js bundle.js 执行以上命令会编译run1.js文件并生成bundle.js文件 在浏览器中打开index.html文件，会看到页面上有“Hello World”。 Loader就像之前说的，如果想要处理除js之外的其他文件，对于css文件，首先需要执行命令来安装css-loader和style-loader 1npm install css-loader style-loader 接下来创建一个style.css文件，代码如下： 123body&#123; background:red;&#125; 修改run1.js文件： 12require(&quot;!style-loader!css-loader!./style.css&quot;);document.write(&quot;Hello World&quot;); 继续使用Webpack命令打包： 1webpack run1.js bundle.js 在浏览器访问index.html会发现背景变成红色。 配置文件可以将一些编译选项放在配置文件中，以便于统一管理。 创建webpack.config.js文件 123456789101112module.exports = &#123; entry: &quot;./run1.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/,loader: &quot;style.loader!css-loader&quot;&#125; ] &#125;&#125;; 接下来只需要执行webpack命令即可生成bundle.js文件 Webpack命令执行后，会默认载入当前目录的webpack.config.js文件。 当你想要查看你添加的loaders模块时。可以在安装webpack之后再生成一个package.json文件,它里面会显示你当前所有的依赖模块，代码如下： 1npm init 默认一直点回车就行 开发环境如果不想每次修改模块之后还要重新编译，那么可以启用监听模式；开启之后，就不需要每次都重新编译，代码如下： 1webpack --watch 当然还有一种方法是启用一个本地服务器，来实现热加载，可以使用webpack-dev-server服务，当然首先需要安装： 1npm install webpack-dev-server -g 运行： 1webpack-dev-server 运行之后一般会通过localhost:8080启用一个express静态资源web服务器，并且会以监听模式自动运行webpack；如果该端口被占用，可以通过“ -port 端口号 ” 来改变服务器端口。 当然webpack还有其他功能。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"npm学习","slug":"npm学习","date":"2017-06-18T07:18:22.000Z","updated":"2019-07-16T09:56:58.712Z","comments":true,"path":"2017/06/18/npm学习/","link":"","permalink":"http://yoursite.com/2017/06/18/npm学习/","excerpt":"","text":"什么是npm？它有什么作用？ npm是和node.js一起的包管理工具，并且在安装node.js时已经安装好了npm,npm常见的使用场景有以下几个: 1231.允许用户从npm服务器下载别人编写的第三方包到本地使用。2.允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。3.允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。 安装npm npm本地安装的命令为: 1npm install npm 全局安装的命令为: 1npm install npm -g 如果要检查是否安装成功可以输入命令行: 1npm -v 来测试是否安装成功。 使用package.jsonpackage.json位于模块的目录下，用于定义包的属性。 在当前目录下产生package.json文件1npm init 安装当前package,json中定义的模块1npm install 注册与提交注册用户1234npm adduserUsername:输入用户名Password:输入密码Email:输入邮箱 编写完模块后输入命令行:1npm publish #发表模块 更新模块 尽管node.js自带pm，但是如果想要更新npm的话。可以输入命令: 1npm update npm -g 搜索模块1npm search &quot;Module Name&quot;","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"gulp学习","slug":"gulp学习","date":"2017-06-15T11:05:28.000Z","updated":"2019-07-16T09:56:55.692Z","comments":true,"path":"2017/06/15/gulp学习/","link":"","permalink":"http://yoursite.com/2017/06/15/gulp学习/","excerpt":"","text":"gulp作为前端开发过程中对代码进行构建的工具，对它进行了解学习是必要的，它可以提高我们的学习和工作效率 要使用gulp，首先要明白它是基于node.js下运行的，所以我们需要先安装node.js，安装完成后再安装gulp，这里分为全局安装gulp与本地安装gulp：对于全局安装，它的目的是为了通过它执行gulp任务;安装的命令提示符是： 1npm install gulp -g 安装好之后，可以使用 1gulp -v 来进行验证，如果出现版本号即为正确安装 而本地安装只需要将”-g”去掉 1npm install gulp 安装完成之后我们需要新建一个package,json文件 说明：package.json是基于node.js项目必不可少的配置文件，它是存放在项目根目录的json文件(在之后的gulpfile.js编写中也可以当做检查gulp插件是否调入的判断)安装的命令提示符 1npm init 这里需要说明一下package.json文件里的内容 123456789101.name:项目名称2.version:版本号3.description:项目描述4.homepage:项目网站5.author:作者姓名6.contributors:其他相关人姓名7.dependencies:包(插件)列表，默认在node_modules目录下8.repository:包(插件)存放地方的类型，可以是git或svn,git可在GitHub上9.main:main字段指定了程序的主入口文件，require(&apos;moduleName&apos;)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js10.keywords:关键字 在gulp里面的主要知识点我个人认为是在于写gulpfile.js文件举例说明 123456var sass = require(&apos;gulp-sass&apos;); //将插件导入文件中并命名gulp.task(&apos;sass&apos;,function()&#123; //定义一个匿名函数return gulp.src(&apos;stylesheets/**/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); gulp.src() –找出需要处理的文件 .pipe() –指定需要执行的功能 gulp.desk() –将处理好的文件放到指定的位置 像例子中的sass就是一个插件，它的功能是将文件变为.css格式的文件,安装方式是 1npm install gulp-sass --save-dev 其他插件的安装方式与用法基本类似,不多描述 下面是我对gulp中的几个API的理解1.gulp.src()利用这个方法可以读取你需要的文件，语法为:1gulp.src(globs[,optios]) globs参数是文件匹配模式，用来匹配文件路径；当有多个模式时，该参数为一个数组；options为可选参数，通常用不到 2.gulp.dest()用来写文件，其语法为:1gulp.dest(path[,optios]) path为写入文件的路径；options为可选参数，通常用不到 3.gulp.task()用来定义任务，语法为:1gulp.task(name[,deps],fn) name为任务名；deps是当前定义的任务需要依赖其他任务；fn为任务函数，任务要执行的代码写在里面 4.gulp.watch()用来监视文件的变化，当文件发生变化后，可以利用它来执行相应的任务,语法为:1gulp.watch(glob[,opta],tasks) glob为要监视的文件匹配模式；opts为一个可选的配置对象，通常不用；tasks为文件变化后要执行的任务，为一个数组","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]}]}